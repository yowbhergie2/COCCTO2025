// HistoricalBalanceService.gs - F1: Initial Balance Migration

/**
 * Save historical balance entry
 * @param {Object} formData - Contains employeeId, month, year, earned, used, dateOfIssuance
 * @returns {Object} Result with success status and message
 */
function saveHistoricalBalance(formData) {
  try {
    // Parse and validate input
    const employeeId = parseInt(formData.employeeId);
    const month = formData.month;
    const year = parseInt(formData.year);
    const cocEarned = parseFloat(formData.cocEarned);
    const cocUsed = parseFloat(formData.cocUsed);
    const dateOfIssuanceStr = formData.dateOfIssuance;
    
    // Validation 1: Check employee exists
    const employee = getEmployeeById_V2(employeeId);
    if (!employee) {
      return {
        success: false,
        message: 'Employee not found'
      };
    }

    // *** BAGONG VALIDATION: Check for duplicates ***
    // PABILIS-FIX: Changed getSheetData to getSheetData_V2 to use Firestore
    const data = getSheetData_V2('CreditBatches');
    
    // PABILIS-FIX: Removed getSheetHeaders and ...Index variables
    // Use object property access instead of array index

    const isDuplicate = data.some(row => {
      // PABILIS-FIX: Check object properties directly (using camelCase field names)
      return row.employeeId === employeeId &&
             row.earnedMonth === month &&
             row.earnedYear === year &&
             row.notes && row.notes.toString().includes('Historical data migration');
    });

    if (isDuplicate) {
      return {
        success: false,
        message: `A historical balance for ${month} ${year} already exists for this employee.`
      };
    }
    // *** END - BAGONG VALIDATION ***
    
    // Validation 2: COC Earned must not exceed 40 hours (monthly cap)
    if (cocEarned > 40) {
      return {
        success: false,
        message: 'COC Earned cannot exceed 40 hours per month (monthly accrual cap)'
      };
    }
    
    // Validation 3: COC Used cannot exceed COC Earned
    if (cocUsed > cocEarned) {
      return {
        success: false,
        message: 'COC Used cannot exceed COC Earned'
      };
    }
    
    // Validation 4: Date of Issuance must be on or after the last day of the earned month
    // Get last day of the earned month
    const lastDayOfMonth = new Date(year, getMonthNumber(month) + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    
    // Parse and normalize dateOfIssuance
    // Add T00:00:00 to avoid timezone issues with date parsing
    const dateOfIssuance = new Date(dateOfIssuanceStr + 'T00:00:00');
    dateOfIssuance.setHours(0, 0, 0, 0);
    
    if (dateOfIssuance < lastDayOfMonth) {
      return {
        success: false,
        message: 'Date of Issuance must be on or after ' + formatDate(lastDayOfMonth)
      };
    }

    // --- BAGONG-DAGDAG: Validation 5: Check if Date of Issuance is within allowed range ---
    // Max date: Last day of the month AFTER the earned month
    const maxIssuanceDate = new Date(year, getMonthNumber(month) + 2, 0);
    maxIssuanceDate.setHours(0, 0, 0, 0);

    if (dateOfIssuance > maxIssuanceDate) {
      return {
        success: false,
        message: `Date of Issuance must be on or before ${formatDate(maxIssuanceDate)} (last day of month after earned month).`
      };
    }

    // Also check if Date of Issuance year matches Earned Year
    if (dateOfIssuance.getFullYear() !== year) {
      return {
        success: false,
        message: `Date of Issuance (${dateOfIssuance.getFullYear()}) must be in the same year as Earned Year (${year}).`
      };
    }
    // --- END ---
    
    // Calculate Remaining balance
    const remaining = cocEarned - cocUsed;
    
    // *** PAKI-AYOS (START): Idinagdag ang logic para sa status ***
    // Tingnan kung 0 ang remaining, gawing "Used" ang status. Kung hindi, "Active".
    const status = remaining > 0 ? 'Active' : 'Used';
    // *** PAKI-AYOS (END) ***
    
    // Calculate Valid Until date: (Date of Issuance + 1 Year) - 1 Day
    const validUntil = new Date(dateOfIssuance);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);
    
    // Check if this would exceed the 120-hour total cap
    const currentBalance = getEmployeeCurrentBalance(employeeId);
    if (currentBalance + remaining > 120) {
      return {
        success: false,
        message: `Adding ${remaining} hours would exceed the 120-hour total balance cap. Current balance: ${currentBalance} hours.`
      };
    }
    
    // Create BatchID
    // PABILIS-FIX: This getNextId call is now Firestore-aware via DatabaseService.gs
    const batchId = getNextId('CreditBatches', 'A');
    const currentEmail = getCurrentUserEmail();
    const currentDate = new Date();
    
    // Prepare CreditBatches row
    const batchRow = [
      batchId,                    // A: BatchID
      employeeId,                 // B: EmployeeID
      month,                      // C: EarnedMonth
      year,                       // D: EarnedYear
      dateOfIssuance,             // E: DateOfIssuance
      validUntil,                 // F: ValidUntil
      cocEarned,                  // G: OriginalHours
      remaining,                  // H: RemainingHours
      status,                     // I: Status  <-- PAKI-AYOS: Pinalitan ng 'status' variable
      currentEmail,               // J: CertifiedBy
      currentDate,                // K: CertifiedDate
      'Historical data migration' // L: Notes
    ];
    
    // Append to CreditBatches
    // PABILIS-FIX: This appendToSheet call is now Firestore-aware via DatabaseService.gs
    appendToSheet('CreditBatches', batchRow);
    
    // Create ledger entries
    const transactionIdEarned = getNextId('Ledger', 'A');
    
    // Ledger entry for Earned
    const ledgerEarnedRow = [
      transactionIdEarned,
      employeeId,
      currentDate,
      'InitialBalance',
      cocEarned,
      batchId,
      'HIST-' + batchId,
      month,
      year,
      currentEmail,
      'Historical balance migration - Earned',
      currentDate
    ];
    appendToSheet('Ledger', ledgerEarnedRow);
    
    // If COC was used, create another ledger entry
    if (cocUsed > 0) {
      const transactionIdUsed = getNextId('Ledger', 'A');
      const ledgerUsedRow = [
        transactionIdUsed,
        employeeId,
        currentDate,
        'InitialBalance',
        -cocUsed,
        batchId,
        'HIST-' + batchId,
        month,
        year,
        currentEmail,
        'Historical balance migration - Used',
        currentDate
      ];
      appendToSheet('Ledger', ledgerUsedRow);
    }
    
    return {
      success: true,
      message: `Historical balance saved successfully. Remaining balance: ${remaining} hours, Valid Until: ${formatDate(validUntil)}`
    };
    
  } catch (error) {
    Logger.log('Error in saveHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error saving historical balance: ' + error.message
    };
  }
}

/**
 * Get month number from month name (0-indexed for JavaScript Date)
 */
function getMonthNumber(monthName) {
  const months = {
    'January': 0, 'February': 1, 'March': 2, 'April': 3,
    'May': 4, 'June': 5, 'July': 6, 'August': 7,
    'September': 8, 'October': 9, 'November': 10, 'December': 11
  };
  return months[monthName];
}

/**
 * Get employee's current total balance (sum of all Active RemainingHours)
 */
function getEmployeeCurrentBalance(employeeId) {
  // PABILIS-FIX: Use getSheetData_V2
  const data = getSheetData_V2('CreditBatches');
  if (!data || data.length === 0) {
    return 0;  // No data
  }

  let totalBalance = 0;
  
  // PABILIS-FIX: Use object properties (using camelCase field names)
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    if (row.employeeId === employeeId && row.status === 'Active') {
      totalBalance += parseFloat(row.remainingHours) || 0;
    }
  }
  
  return totalBalance;
}

/**
 * Get a single historical balance record by batch ID
 * @param {number} batchId - Batch ID to retrieve
 * @returns {Object} Result with success status and batch data
 */
function getHistoricalBalanceByBatchId(batchId) {
  try {
    Logger.log('getHistoricalBalanceByBatchId called with batchId: ' + batchId + ' (type: ' + typeof batchId + ')');

    // FIX: Try getting the batch directly by ID first (more reliable)
    const batch = getRowById('CreditBatches', batchId, 0);

    if (!batch) {
      Logger.log('No batch found with batchId: ' + batchId);
      return {
        success: false,
        message: 'Historical balance record not found (Batch ID: ' + batchId + ')'
      };
    }

    Logger.log('Found batch: ' + JSON.stringify(batch));
    Logger.log('dateOfIssuance type: ' + typeof batch.dateOfIssuance + ', value: ' + batch.dateOfIssuance);
    Logger.log('validUntil type: ' + typeof batch.validUntil + ', value: ' + batch.validUntil);

    // Convert dates to ISO string format for proper serialization
    // Handle both Date objects and ISO strings from Firestore
    let dateOfIssuance;
    if (batch.dateOfIssuance instanceof Date) {
      dateOfIssuance = batch.dateOfIssuance.toISOString().split('T')[0];
    } else if (typeof batch.dateOfIssuance === 'string') {
      // Already a string, just ensure it's in YYYY-MM-DD format
      dateOfIssuance = batch.dateOfIssuance.split('T')[0];
    } else {
      dateOfIssuance = batch.dateOfIssuance;
    }

    let validUntil;
    if (batch.validUntil instanceof Date) {
      validUntil = batch.validUntil.toISOString().split('T')[0];
    } else if (typeof batch.validUntil === 'string') {
      // Already a string, just ensure it's in YYYY-MM-DD format
      validUntil = batch.validUntil.split('T')[0];
    } else {
      validUntil = batch.validUntil;
    }

    Logger.log('Serialized dateOfIssuance: ' + dateOfIssuance);
    Logger.log('Serialized validUntil: ' + validUntil);

    return {
      success: true,
      data: {
        batchId: batch.batchId,
        employeeId: batch.employeeId,
        month: batch.earnedMonth,
        year: batch.earnedYear,
        cocEarned: batch.originalHours,
        cocUsed: batch.originalHours - batch.remainingHours,
        dateOfIssuance: dateOfIssuance,
        validUntil: validUntil,
        status: batch.status
      }
    };

  } catch (error) {
    Logger.log('Error in getHistoricalBalanceByBatchId: ' + error.toString());
    Logger.log('Error stack: ' + error.stack);
    return {
      success: false,
      message: 'Error retrieving historical balance: ' + error.message
    };
  }
}

/**
 * Check if an employee has any overtime logs
 * Used to prevent editing/deleting historical balances after overtime has been logged
 * @param {number} employeeId - Employee ID to check
 * @returns {Object} Result with hasOvertimeLogs boolean
 */
function checkEmployeeHasOvertimeLogs(employeeId) {
  try {
    // PABILIS-FIX: Use getSheetData_V2
    // --- OPTIMIZATION START: Use queryDocuments for speed ---
    // Imbis na i-load lahat, mag-query lang para sa specific employee
    // Ensure employeeId is a number to match Firestore data type
    const logs = queryDocuments('overtimeLogs', 'employeeId', '==', parseInt(employeeId)); 
    
    if (logs && logs.length > 0) {
      // May nahanap na kahit isang log
      return { hasOvertimeLogs: true };
    } else {
      // Walang nahanap
      return { hasOvertimeLogs: false };
    }
    // --- OPTIMIZATION END ---

  } catch (error) {
    Logger.log('Error in checkEmployeeHasOvertimeLogs: ' + error.toString());
    return { hasOvertimeLogs: false }; // Fail safe
  }
}

/**
 * Update a historical balance record
 * @param {number} batchId - Batch ID to update
 * @param {Object} formData - Contains month, year, earned, used, dateOfIssuance
 * @returns {Object} Result with success status and message
 */
function updateHistoricalBalance(batchId, formData) {
  try {
    // Get the existing batch
    const batchResult = getHistoricalBalanceByBatchId(batchId);
    if (!batchResult.success) {
      return batchResult;
    }

    const existingBatch = batchResult.data;

    // Parse input
    const month = formData.month;
    const year = parseInt(formData.year);
    const cocEarned = parseFloat(formData.cocEarned);
    const cocUsed = parseFloat(formData.cocUsed);
    const dateOfIssuanceStr = formData.dateOfIssuance;

    // Run the same validations as saveHistoricalBalance
    if (cocEarned > 40) {
      return {
        success: false,
        message: 'COC Earned cannot exceed 40 hours per month (monthly accrual cap)'
      };
    }

    if (cocUsed > cocEarned) {
      return {
        success: false,
        message: 'COC Used cannot exceed COC Earned'
      };
    }

    const lastDayOfMonth = new Date(year, getMonthNumber(month) + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);

    const dateOfIssuance = new Date(dateOfIssuanceStr + 'T00:00:00');
    dateOfIssuance.setHours(0, 0, 0, 0);

    if (dateOfIssuance < lastDayOfMonth) {
      return {
        success: false,
        message: 'Date of Issuance must be on or after ' + formatDate(lastDayOfMonth)
      };
    }

    const maxIssuanceDate = new Date(year, getMonthNumber(month) + 2, 0);
    maxIssuanceDate.setHours(0, 0, 0, 0);

    if (dateOfIssuance > maxIssuanceDate) {
      return {
        success: false,
        message: `Date of Issuance must be on or before ${formatDate(maxIssuanceDate)} (last day of month after earned month).`
      };
    }

    if (dateOfIssuance.getFullYear() !== year) {
      return {
        success: false,
        message: `Date of Issuance (${dateOfIssuance.getFullYear()}) must be in the same year as Earned Year (${year}).`
      };
    }

    // Calculate new values
    const remaining = cocEarned - cocUsed;
    const status = remaining > 0 ? 'Active' : 'Used';

    // Calculate Valid Until date
    const validUntil = new Date(dateOfIssuance);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);

    // Check total balance cap (excluding current batch's old remaining)
    const currentTotalBalance = getEmployeeCurrentBalance(existingBatch.employeeId);
    const oldRemaining = parseFloat(existingBatch.cocEarned) - parseFloat(existingBatch.cocUsed);
    const newTotalBalance = currentTotalBalance - oldRemaining + remaining;

    if (newTotalBalance > 120) {
      return {
        success: false,
        message: `Updating to ${remaining} hours would exceed the 120-hour total balance cap. Current total: ${currentTotalBalance} hours.`
      };
    }

    // Update CreditBatches - CRITICAL: Include batchId and employeeId!
    const batchData = {
      batchId: parseInt(batchId),      // CRITICAL: Preserve batchId field
      employeeId: parseInt(existingBatch.employeeId), // CRITICAL: Preserve employeeId field
      earnedMonth: month,
      earnedYear: year,
      dateOfIssuance: dateOfIssuance,  // Keep as Date object for Firestore
      validUntil: validUntil,           // Keep as Date object for Firestore
      originalHours: cocEarned,
      remainingHours: remaining,
      status: status,
      updatedAt: getCurrentTimestamp()
    };

    Logger.log('updateHistoricalBalance - Updating batch ' + batchId + ' with data:');
    Logger.log('  batchId: ' + batchId + ' (PRESERVED)');
    Logger.log('  employeeId: ' + existingBatch.employeeId + ' (PRESERVED)');
    Logger.log('  earnedMonth: ' + month);
    Logger.log('  earnedYear: ' + year);
    Logger.log('  dateOfIssuance: ' + dateOfIssuance + ' (type: ' + typeof dateOfIssuance + ')');
    Logger.log('  validUntil: ' + validUntil + ' (type: ' + typeof validUntil + ')');
    Logger.log('  originalHours: ' + cocEarned);
    Logger.log('  remainingHours: ' + remaining);
    Logger.log('  status: ' + status);

    updateRowById('CreditBatches', batchId, batchData, 0);

    Logger.log('updateHistoricalBalance - Update complete for batch ' + batchId);

    // Note: Ledger entries are not updated as they represent historical transactions

    return {
      success: true,
      message: `Historical balance updated successfully. New remaining balance: ${remaining} hours, Valid Until: ${formatDate(validUntil)}`
    };

  } catch (error) {
    Logger.log('Error in updateHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error updating historical balance: ' + error.message
    };
  }
}

/**
 * Get all historical balance months for an employee
 * Used to disable month/year combinations in the overtime logging form
 * @param {number} employeeId - Employee ID
 * @returns {Array} Array of objects with month and year properties
 */
function getHistoricalBalanceMonths(employeeId) {
  try {
    Logger.log('getHistoricalBalanceMonths called for employeeId: ' + employeeId);

    // Query CreditBatches for this employee
    const batches = queryDocuments('creditBatches', 'employeeId', '==', parseInt(employeeId));
    Logger.log('Found batches: ' + (batches ? batches.length : 0));

    if (!batches || batches.length === 0) {
      Logger.log('No batches found, returning empty array');
      return [];
    }

    // Extract unique month/year combinations as simple array of objects
    const monthYearMap = {};

    batches.forEach(batch => {
      const month = batch.earnedMonth;
      const year = batch.earnedYear;
      const key = month + '-' + year;

      if (!monthYearMap[key]) {
        monthYearMap[key] = {
          month: month,
          year: year
        };
        Logger.log('Added: month=' + month + ', year=' + year);
      }
    });

    // Convert map to array
    const result = [];
    for (const key in monthYearMap) {
      result.push(monthYearMap[key]);
    }

    Logger.log('Returning ' + result.length + ' unique months');
    Logger.log('Result JSON: ' + JSON.stringify(result));

    return result;

  } catch (error) {
    Logger.log('Error in getHistoricalBalanceMonths: ' + error.toString());
    return [];
  }
}

/**
 * Delete a historical balance record
 * Only allowed if employee has no overtime logs yet
 * @param {number} batchId - Batch ID to delete
 * @returns {Object} Result with success status and message
 */
function deleteHistoricalBalance(batchId) {
  try {
    Logger.log('deleteHistoricalBalance - Starting deletion for batchId: ' + batchId);

    // FIX: Use getRowById instead of queryDocuments for more reliable retrieval
    const batch = getRowById('CreditBatches', batchId, 0);

    if (!batch) {
      Logger.log('deleteHistoricalBalance - Batch not found: ' + batchId);
      return {
        success: false,
        message: 'Historical balance record not found'
      };
    }

    Logger.log('deleteHistoricalBalance - Found batch, proceeding with deletion');

    // Delete the batch from CreditBatches
    deleteRowById('CreditBatches', batchId, 0);
    Logger.log('deleteHistoricalBalance - Deleted from CreditBatches');

    // OPTIMIZATION: Query ledger entries by batchId
    // Try both number and string versions to ensure we find all entries
    let ledgerEntries = queryDocuments('ledger', 'batchId', '==', parseInt(batchId));

    // If no results with number, try with string
    if (!ledgerEntries || ledgerEntries.length === 0) {
      ledgerEntries = queryDocuments('ledger', 'batchId', '==', String(batchId));
    }

    if (ledgerEntries && ledgerEntries.length > 0) {
      Logger.log('deleteHistoricalBalance - Deleting ' + ledgerEntries.length + ' related ledger entries');
      for (let i = 0; i < ledgerEntries.length; i++) {
        deleteRowById('Ledger', ledgerEntries[i].transactionId, 0);
      }
      Logger.log('deleteHistoricalBalance - Deleted all ledger entries');
    } else {
      Logger.log('deleteHistoricalBalance - No ledger entries found for batchId: ' + batchId);
    }

    Logger.log('deleteHistoricalBalance - Deletion complete for batchId: ' + batchId);

    return {
      success: true,
      message: 'Historical balance deleted successfully'
    };
  } catch (error) {
    Logger.log('Error in deleteHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error deleting historical balance: ' + error.message
    };
  }
}

// HistoricalBalanceService.gs - F1: Initial Balance Migration

/**
 * Save historical balance entry
 * @param {Object} formData - Contains employeeId, month, year, earned, used, dateOfIssuance
 * @returns {Object} Result with success status and message
 */
function saveHistoricalBalance(formData) {
  try {
    // Parse and validate input
    const employeeId = parseInt(formData.employeeId);
    const month = formData.month;
    const year = parseInt(formData.year);
    const cocEarned = parseFloat(formData.cocEarned);
    const cocUsed = parseFloat(formData.cocUsed);
    const dateOfIssuanceStr = formData.dateOfIssuance;
    
    // Validation 1: Check employee exists
    const employee = getEmployeeById(employeeId);
    if (!employee) {
      return {
        success: false,
        message: 'Employee not found'
      };
    }

    // *** BAGONG VALIDATION: Check for duplicates ***
    const data = getSheetData('CreditBatches');
    const headers = getSheetHeaders('CreditBatches');
    const employeeIdIndex = headers.indexOf('EmployeeID');
    const monthIndex = headers.indexOf('EarnedMonth');
    const yearIndex = headers.indexOf('EarnedYear');
    const notesIndex = headers.indexOf('Notes');

    const isDuplicate = data.some(row => {
      return row[employeeIdIndex] === employeeId &&
             row[monthIndex] === month &&
             row[yearIndex] === year &&
             row[notesIndex] && row[notesIndex].toString().includes('Historical data migration');
    });

    if (isDuplicate) {
      return {
        success: false,
        message: `A historical balance for ${month} ${year} already exists for this employee.`
      };
    }
    // *** END - BAGONG VALIDATION ***
    
    // Validation 2: COC Earned must not exceed 40 hours (monthly cap)
    if (cocEarned > 40) {
      return {
        success: false,
        message: 'COC Earned cannot exceed 40 hours per month (monthly accrual cap)'
      };
    }
    
    // Validation 3: COC Used cannot exceed COC Earned
    if (cocUsed > cocEarned) {
      return {
        success: false,
        message: 'COC Used cannot exceed COC Earned'
      };
    }
    
    // Validation 4: Date of Issuance must be on or after the last day of the earned month
    // Get last day of the earned month
    const lastDayOfMonth = new Date(year, getMonthNumber(month) + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    
    // Parse and normalize dateOfIssuance
    const dateOfIssuance = new Date(dateOfIssuanceStr + 'T00:00:00');
    dateOfIssuance.setHours(0, 0, 0, 0);
    
    if (dateOfIssuance < lastDayOfMonth) {
      return {
        success: false,
        message: 'Date of Issuance must be on or after ' + formatDate(lastDayOfMonth)
      };
    }
    
    // Calculate Remaining balance
    const remaining = cocEarned - cocUsed;
    
    // *** PAKI-AYOS (START): Idinagdag ang logic para sa status ***
    // Tingnan kung 0 ang remaining, gawing "Used" ang status. Kung hindi, "Active".
    const status = remaining > 0 ? 'Active' : 'Used';
    // *** PAKI-AYOS (END) ***
    
    // Calculate Valid Until date: (Date of Issuance + 1 Year) - 1 Day
    const validUntil = new Date(dateOfIssuance);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);
    
    // Check if this would exceed the 120-hour total cap
    const currentBalance = getEmployeeCurrentBalance(employeeId);
    if (currentBalance + remaining > 120) {
      return {
        success: false,
        message: `Adding ${remaining} hours would exceed the 120-hour total balance cap. Current balance: ${currentBalance} hours.`
      };
    }
    
    // Create BatchID
    const batchId = getNextId('CreditBatches', 'A');
    const currentEmail = getCurrentUserEmail();
    const currentDate = new Date();
    
    // Prepare CreditBatches row
    const batchRow = [
      batchId,                    // A: BatchID
      employeeId,                 // B: EmployeeID
      month,                      // C: EarnedMonth
      year,                       // D: EarnedYear
      dateOfIssuance,             // E: DateOfIssuance
      validUntil,                 // F: ValidUntil
      cocEarned,                  // G: OriginalHours
      remaining,                  // H: RemainingHours
      status,                     // I: Status  <-- PAKI-AYOS: Pinalitan ng 'status' variable
      currentEmail,               // J: CertifiedBy
      currentDate,                // K: CertifiedDate
      'Historical data migration' // L: Notes
    ];
    
    // Append to CreditBatches
    appendToSheet('CreditBatches', batchRow);
    
    // Create ledger entries
    const transactionIdEarned = getNextId('Ledger', 'A');
    
    // Ledger entry for Earned
    const ledgerEarnedRow = [
      transactionIdEarned,
      employeeId,
      currentDate,
      'InitialBalance',
      cocEarned,
      batchId,
      'HIST-' + batchId,
      month,
      year,
      currentEmail,
      'Historical balance migration - Earned',
      currentDate
    ];
    appendToSheet('Ledger', ledgerEarnedRow);
    
    // If COC was used, create another ledger entry
    if (cocUsed > 0) {
      const transactionIdUsed = getNextId('Ledger', 'A');
      const ledgerUsedRow = [
        transactionIdUsed,
        employeeId,
        currentDate,
        'InitialBalance',
        -cocUsed,
        batchId,
        'HIST-' + batchId,
        month,
        year,
        currentEmail,
        'Historical balance migration - Used',
        currentDate
      ];
      appendToSheet('Ledger', ledgerUsedRow);
    }
    
    return {
      success: true,
      message: `Historical balance saved successfully. Remaining balance: ${remaining} hours, Valid Until: ${formatDate(validUntil)}`
    };
    
  } catch (error) {
    Logger.log('Error in saveHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error saving historical balance: ' + error.message
    };
  }
}

/**
 * Get month number from month name (0-indexed for JavaScript Date)
 */
function getMonthNumber(monthName) {
  const months = {
    'January': 0, 'February': 1, 'March': 2, 'April': 3,
    'May': 4, 'June': 5, 'July': 6, 'August': 7,
    'September': 8, 'October': 9, 'November': 10, 'December': 11
  };
  return months[monthName];
}

/**
 * Get employee's current total balance (sum of all Active RemainingHours)
 */
function getEmployeeCurrentBalance(employeeId) {
  const sheet = getDbSheet('CreditBatches');
  if (!sheet) {
    Logger.log('getEmployeeCurrentBalance: CreditBatches sheet not found');
    return 0;
  }

  const data = sheet.getDataRange().getValues();
  if (!data || data.length <= 1) {
    return 0;  // No data or only headers
  }

  const headers = data[0];
  
  // Get column indices
  const employeeIdIndex = headers.indexOf('EmployeeID');
  const statusIndex = headers.indexOf('Status');
  const remainingIndex = headers.indexOf('RemainingHours');
  
  let totalBalance = 0;
  
  // Skip header row (index 0)
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (row[employeeIdIndex] === employeeId && row[statusIndex] === 'Active') {
      totalBalance += parseFloat(row[remainingIndex]) || 0;
    }
  }
  
  return totalBalance;
}

/**
 * Check if an employee has any overtime logs
 * Used to prevent editing/deleting historical balances after overtime has been logged
 * @param {number} employeeId - Employee ID to check
 * @returns {Object} Result with hasOvertimeLogs boolean
 */
function checkEmployeeHasOvertimeLogs(employeeId) {
  try {
    const sheet = getDbSheet('OvertimeLogs');
    if (!sheet) {
      return { hasOvertimeLogs: false };
    }

    const data = sheet.getDataRange().getValues();
    if (!data || data.length <= 1) {
      return { hasOvertimeLogs: false };  // No data or only headers
    }

    const headers = data[0];
    const employeeIdIndex = headers.indexOf('EmployeeID');

    // Check if any row belongs to this employee
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row[employeeIdIndex] === employeeId) {
        return { hasOvertimeLogs: true };
      }
    }

    return { hasOvertimeLogs: false };
  } catch (error) {
    Logger.log('Error in checkEmployeeHasOvertimeLogs: ' + error.toString());
    return { hasOvertimeLogs: false };
  }
}

/**
 * Delete a historical balance record
 * Only allowed if employee has no overtime logs yet
 * @param {number} batchId - Batch ID to delete
 * @returns {Object} Result with success status and message
 */
function deleteHistoricalBalance(batchId) {
  try {
    const creditBatchesSheet = getDbSheet('CreditBatches');
    if (!creditBatchesSheet) {
      return {
        success: false,
        message: 'CreditBatches sheet not found'
      };
    }

    const data = creditBatchesSheet.getDataRange().getValues();
    if (!data || data.length <= 1) {
      return {
        success: false,
        message: 'No records found'
      };
    }

    const headers = data[0];
    const batchIdIndex = headers.indexOf('BatchID');
    const notesIndex = headers.indexOf('Notes');

    // Find the row to delete
    let rowToDelete = -1;
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (row[batchIdIndex] === batchId) {
        // Verify it's a historical record
        if (!row[notesIndex] || !row[notesIndex].toString().includes('Historical data migration')) {
          return {
            success: false,
            message: 'This is not a historical balance record and cannot be deleted here'
          };
        }
        rowToDelete = i + 1; // +1 because sheet rows are 1-indexed
        break;
      }
    }

    if (rowToDelete === -1) {
      return {
        success: false,
        message: 'Historical balance record not found'
      };
    }

    // Delete the row from CreditBatches
    creditBatchesSheet.deleteRow(rowToDelete);

    // Also delete related Ledger entries
    const ledgerSheet = getDbSheet('Ledger');
    if (ledgerSheet) {
      const ledgerData = ledgerSheet.getDataRange().getValues();
      const ledgerHeaders = ledgerData[0];
      const ledgerBatchIdIndex = ledgerHeaders.indexOf('BatchID');

      // Delete from bottom to top to avoid index shifting issues
      for (let i = ledgerData.length - 1; i >= 1; i--) {
        const row = ledgerData[i];
        if (row[ledgerBatchIdIndex] === batchId) {
          ledgerSheet.deleteRow(i + 1); // +1 because sheet rows are 1-indexed
        }
      }
    }

    return {
      success: true,
      message: 'Historical balance deleted successfully'
    };
  } catch (error) {
    Logger.log('Error in deleteHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error deleting historical balance: ' + error.message
    };
  }
}

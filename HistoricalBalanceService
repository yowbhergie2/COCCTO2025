// HistoricalBalanceService.gs - F1: Initial Balance Migration

/**
 * Save historical balance entry
 * @param {Object} formData - Contains employeeId, month, year, earned, used, dateOfIssuance
 * @returns {Object} Result with success status and message
 */
function saveHistoricalBalance(formData) {
  try {
    // Parse and validate input
    const employeeId = parseInt(formData.employeeId);
    const month = formData.month;
    const year = parseInt(formData.year);
    const cocEarned = parseFloat(formData.cocEarned);
    const cocUsed = parseFloat(formData.cocUsed);
    const dateOfIssuanceStr = formData.dateOfIssuance;
    
    // Validation 1: Check employee exists
    const employee = getEmployeeById_V2(employeeId);
    if (!employee) {
      return {
        success: false,
        message: 'Employee not found'
      };
    }

    // *** BAGONG VALIDATION: Check for duplicates ***
    // PABILIS-FIX: Changed getSheetData to getSheetData_V2 to use Firestore
    const data = getSheetData_V2('CreditBatches');
    
    // PABILIS-FIX: Removed getSheetHeaders and ...Index variables
    // Use object property access instead of array index

    const isDuplicate = data.some(row => {
      // PABILIS-FIX: Check object properties directly (using camelCase field names)
      return row.employeeId === employeeId &&
             row.earnedMonth === month &&
             row.earnedYear === year &&
             row.notes && row.notes.toString().includes('Historical data migration');
    });

    if (isDuplicate) {
      return {
        success: false,
        message: `A historical balance for ${month} ${year} already exists for this employee.`
      };
    }
    // *** END - BAGONG VALIDATION ***
    
    // Validation 2: COC Earned must not exceed 40 hours (monthly cap)
    if (cocEarned > 40) {
      return {
        success: false,
        message: 'COC Earned cannot exceed 40 hours per month (monthly accrual cap)'
      };
    }
    
    // Validation 3: COC Used cannot exceed COC Earned
    if (cocUsed > cocEarned) {
      return {
        success: false,
        message: 'COC Used cannot exceed COC Earned'
      };
    }
    
    // Validation 4: Date of Issuance must be on or after the last day of the earned month
    // Get last day of the earned month
    const lastDayOfMonth = new Date(year, getMonthNumber(month) + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    
    // Parse and normalize dateOfIssuance
    // Add T00:00:00 to avoid timezone issues with date parsing
    const dateOfIssuance = new Date(dateOfIssuanceStr + 'T00:00:00');
    dateOfIssuance.setHours(0, 0, 0, 0);
    
    if (dateOfIssuance < lastDayOfMonth) {
      return {
        success: false,
        message: 'Date of Issuance must be on or after ' + formatDate(lastDayOfMonth)
      };
    }

    // --- BAGONG-DAGDAG: Validation 5: Check if Date of Issuance is within allowed range ---
    // Max date: Last day of the month AFTER the earned month
    const maxIssuanceDate = new Date(year, getMonthNumber(month) + 2, 0);
    maxIssuanceDate.setHours(0, 0, 0, 0);

    if (dateOfIssuance > maxIssuanceDate) {
      return {
        success: false,
        message: `Date of Issuance must be on or before ${formatDate(maxIssuanceDate)} (last day of month after earned month).`
      };
    }

    // Also check if Date of Issuance year matches Earned Year
    if (dateOfIssuance.getFullYear() !== year) {
      return {
        success: false,
        message: `Date of Issuance (${dateOfIssuance.getFullYear()}) must be in the same year as Earned Year (${year}).`
      };
    }
    // --- END ---
    
    // Calculate Remaining balance
    const remaining = cocEarned - cocUsed;
    
    // *** PAKI-AYOS (START): Idinagdag ang logic para sa status ***
    // Tingnan kung 0 ang remaining, gawing "Used" ang status. Kung hindi, "Active".
    const status = remaining > 0 ? 'Active' : 'Used';
    // *** PAKI-AYOS (END) ***
    
    // Calculate Valid Until date: (Date of Issuance + 1 Year) - 1 Day
    const validUntil = new Date(dateOfIssuance);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);
    
    // Check if this would exceed the 120-hour total cap
    const currentBalance = getEmployeeCurrentBalance(employeeId);
    if (currentBalance + remaining > 120) {
      return {
        success: false,
        message: `Adding ${remaining} hours would exceed the 120-hour total balance cap. Current balance: ${currentBalance} hours.`
      };
    }
    
    // Create BatchID
    // PABILIS-FIX: This getNextId call is now Firestore-aware via DatabaseService.gs
    const batchId = getNextId('CreditBatches', 'A');
    const currentEmail = getCurrentUserEmail();
    const currentDate = new Date();
    
    // Prepare CreditBatches row
    const batchRow = [
      batchId,                    // A: BatchID
      employeeId,                 // B: EmployeeID
      month,                      // C: EarnedMonth
      year,                       // D: EarnedYear
      dateOfIssuance,             // E: DateOfIssuance
      validUntil,                 // F: ValidUntil
      cocEarned,                  // G: OriginalHours
      remaining,                  // H: RemainingHours
      status,                     // I: Status  <-- PAKI-AYOS: Pinalitan ng 'status' variable
      currentEmail,               // J: CertifiedBy
      currentDate,                // K: CertifiedDate
      'Historical data migration' // L: Notes
    ];
    
    // Append to CreditBatches
    // PABILIS-FIX: This appendToSheet call is now Firestore-aware via DatabaseService.gs
    appendToSheet('CreditBatches', batchRow);
    
    // Create ledger entries
    const transactionIdEarned = getNextId('Ledger', 'A');
    
    // Ledger entry for Earned
    const ledgerEarnedRow = [
      transactionIdEarned,
      employeeId,
      currentDate,
      'InitialBalance',
      cocEarned,
      batchId,
      'HIST-' + batchId,
      month,
      year,
      currentEmail,
      'Historical balance migration - Earned',
      currentDate
    ];
    appendToSheet('Ledger', ledgerEarnedRow);
    
    // If COC was used, create another ledger entry
    if (cocUsed > 0) {
      const transactionIdUsed = getNextId('Ledger', 'A');
      const ledgerUsedRow = [
        transactionIdUsed,
        employeeId,
        currentDate,
        'InitialBalance',
        -cocUsed,
        batchId,
        'HIST-' + batchId,
        month,
        year,
        currentEmail,
        'Historical balance migration - Used',
        currentDate
      ];
      appendToSheet('Ledger', ledgerUsedRow);
    }
    
    return {
      success: true,
      message: `Historical balance saved successfully. Remaining balance: ${remaining} hours, Valid Until: ${formatDate(validUntil)}`
    };
    
  } catch (error) {
    Logger.log('Error in saveHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error saving historical balance: ' + error.message
    };
  }
}

/**
 * Get month number from month name (0-indexed for JavaScript Date)
 */
function getMonthNumber(monthName) {
  const months = {
    'January': 0, 'February': 1, 'March': 2, 'April': 3,
    'May': 4, 'June': 5, 'July': 6, 'August': 7,
    'September': 8, 'October': 9, 'November': 10, 'December': 11
  };
  return months[monthName];
}

/**
 * Get employee's current total balance (sum of all Active RemainingHours)
 */
function getEmployeeCurrentBalance(employeeId) {
  // PABILIS-FIX: Use getSheetData_V2
  const data = getSheetData_V2('CreditBatches');
  if (!data || data.length === 0) {
    return 0;  // No data
  }

  let totalBalance = 0;
  
  // PABILIS-FIX: Use object properties (using camelCase field names)
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    if (row.employeeId === employeeId && row.status === 'Active') {
      totalBalance += parseFloat(row.remainingHours) || 0;
    }
  }
  
  return totalBalance;
}

/**
 * Check if an employee has any overtime logs
 * Used to prevent editing/deleting historical balances after overtime has been logged
 * @param {number} employeeId - Employee ID to check
 * @returns {Object} Result with hasOvertimeLogs boolean
 */
function checkEmployeeHasOvertimeLogs(employeeId) {
  try {
    // PABILIS-FIX: Use getSheetData_V2
    // --- OPTIMIZATION START: Use queryDocuments for speed ---
    // Imbis na i-load lahat, mag-query lang para sa specific employee
    // Siguraduhin na ang employeeId ay string kapag nag-query sa Firestore
    const logs = queryDocuments('overtimeLogs', 'employeeId', '==', String(employeeId)); 
    
    if (logs && logs.length > 0) {
      // May nahanap na kahit isang log
      return { hasOvertimeLogs: true };
    } else {
      // Walang nahanap
      return { hasOvertimeLogs: false };
    }
    // --- OPTIMIZATION END ---

  } catch (error) {
    Logger.log('Error in checkEmployeeHasOvertimeLogs: ' + error.toString());
    return { hasOvertimeLogs: false }; // Fail safe
  }
}

/**
 * Delete a historical balance record
 * Only allowed if employee has no overtime logs yet
 * @param {number} batchId - Batch ID to delete
 * @returns {Object} Result with success status and message
 */
function deleteHistoricalBalance(batchId) {
  try {
    // PABILIS-FIX: Use getSheetData_V2
    const data = getSheetData_V2('CreditBatches');
    if (!data || data.length === 0) {
      return {
        success: false,
        message: 'No records found'
      };
    }

    // Find the document to delete
    let docToDelete = null;
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      // PABILIS-FIX: Use object properties
      if (row.BatchID === batchId) {
        // --- FIX: Tinanggal ang validation para sa "Historical data migration" note ---
        // Ito 'yung pumipigil sa pag-delete ng ibang batches.
        // Ngayon, basta mahanap ang BatchID, ide-delete na niya.
        // if (!row.Notes || !row.Notes.toString().includes('Historical data migration')) {
        //   return {
        //     success: false,
        //     message: 'This is not a historical balance record and cannot be deleted here'
        //   };
        // }
        docToDelete = row;
        break;
      }
    }

    if (!docToDelete) {
      return {
        success: false,
        message: 'Historical balance record not found'
      };
    }

    // Delete the row from CreditBatches
    // PABILIS-FIX: Use deleteRowById (which is Firestore-aware)
    deleteRowById('CreditBatches', batchId, 0);

    // Also delete related Ledger entries
    // PABILIS-FIX: Use getSheetData_V2
    const ledgerData = getSheetData_V2('Ledger');
    if (ledgerData && ledgerData.length > 0) {
      const ledgerDocsToDelete = [];
      for (let i = 0; i < ledgerData.length; i++) {
        const row = ledgerData[i];
        // PABILIS-FIX: Use object properties
        if (row.BatchID === batchId) {
          // PABILIS-FIX: Use deleteRowById
          deleteRowById('Ledger', row.TransactionID, 0);
        }
      }
    }

    return {
      success: true,
      message: 'Historical balance deleted successfully'
    };
  } catch (error) {
    Logger.log('Error in deleteHistoricalBalance: ' + error.toString());
    return {
      success: false,
      message: 'Error deleting historical balance: ' + error.message
    };
  }
}

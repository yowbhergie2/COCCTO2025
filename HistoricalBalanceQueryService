// HistoricalBalanceQueryService.gs - Query historical balance records

/**
 * Get all historical balance records for an employee
 * @param {number} employeeId - The employee ID
 * @returns {Array} Array of historical balance records
 * UPDATED: Now uses Firestore instead of Sheets
 * Shows all CreditBatches for the employee (not just historical migration ones)
 */
function getEmployeeHistoricalBalances(employeeId) {
  try {
    // Get all CreditBatches documents from Firestore
    const data = getSheetData_V2('CreditBatches');

    if (!data || data.length === 0) {
      return [];
    }

    const records = [];

    // Get current date for status calculation
    const now = new Date();
    now.setHours(0, 0, 0, 0);

    // Process each document
    for (let i = 0; i < data.length; i++) {
      const doc = data[i];

      // Check if this batch belongs to this employee
      // Show all batches, not just historical migration ones
      if (doc.employeeId == employeeId &&
          doc.originalHours !== undefined &&
          typeof doc.originalHours === 'number') {

        // Calculate COC Used based on Original - Remaining
        const cocEarned = parseFloat(doc.originalHours) || 0;
        const remaining = parseFloat(doc.remainingHours) || 0;
        const cocUsed = cocEarned - remaining;

        // Calculate current status (check if expired)
        let currentStatus = doc.status;
        const validUntil = doc.validUntil ? new Date(doc.validUntil) : null;

        if (currentStatus === 'Active' && validUntil && validUntil < now) {
          currentStatus = 'Expired';
        }

        // Handle month/year - some batches have earnedMonth/earnedYear, others have earnedDate
        let month, year;
        if (doc.earnedMonth && doc.earnedYear) {
          month = doc.earnedMonth;
          year = doc.earnedYear;
        } else if (doc.earnedDate) {
          const earnedDate = new Date(doc.earnedDate);
          const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December'];
          month = monthNames[earnedDate.getMonth()];
          year = earnedDate.getFullYear();
        } else {
          // Skip if we can't determine month/year
          return;
        }

        // Handle dateOfIssuance - use earnedDate if dateOfIssuance is not present
        const dateOfIssuance = doc.dateOfIssuance || doc.earnedDate;

        records.push({
          batchId: doc.batchId,
          month: month,
          year: year,
          cocEarned: cocEarned.toFixed(1),
          cocUsed: cocUsed.toFixed(1),
          remaining: remaining.toFixed(1),
          dateOfIssuance: formatDate(dateOfIssuance),
          validUntil: formatDate(validUntil),
          status: currentStatus
        });
      }
    }
    
    // Sort by year and month (most recent first)
    records.sort((a, b) => {
      if (a.year !== b.year) {
        return b.year - a.year;
      }
      const monthOrder = {
        'January': 1, 'February': 2, 'March': 3, 'April': 4,
        'May': 5, 'June': 6, 'July': 7, 'August': 8,
        'September': 9, 'October': 10, 'November': 11, 'December': 12
      };
      return monthOrder[b.month] - monthOrder[a.month];
    });
    
    return records;
    
  } catch (error) {
    Logger.log('Error in getEmployeeHistoricalBalances: ' + error.toString());
    return [];
  }
}

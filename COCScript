<script>
  // ========== LOG OVERTIME PAGE ==========

  let rowCounter = 0;
  let existingDatabaseDates = [];
  let duplicateContext = null;
  let pendingDuplicateAction = null;

  /**
   * Initialize Log Overtime form when page loads
   */
  function initLogOvertimeForm() {
    // Populate years
    const yearSelect = document.getElementById('year');
    if (yearSelect) {
      const currentYear = new Date().getFullYear();
      for (let i = 0; i <= 2; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (i === 0) option.selected = true;
        yearSelect.appendChild(option);
      }
    }

    // Load employees
    google.script.run
      .withSuccessHandler(employees => {
        const empSelect = document.getElementById('employeeId');
        if (empSelect) {
          employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = emp.name;
            empSelect.appendChild(option);
          });
        }
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();

    // Add event listeners
    const empSelect = document.getElementById('employeeId');
    const monthSelect = document.getElementById('month');
    const yearSelectElem = document.getElementById('year');

    if (empSelect) {
      empSelect.addEventListener('change', () => {
        loadExistingDates();
        checkAddDayButtonState();
      });
    }
    if (monthSelect) {
      monthSelect.addEventListener('change', () => {
        loadExistingDates();
        updateDateInputConstraints();
        checkAddDayButtonState();
      });
    }
    if (yearSelectElem) {
      yearSelectElem.addEventListener('change', () => {
        loadExistingDates();
        updateDateInputConstraints();
        checkAddDayButtonState();
      });
    }

    // Initial button and entries state check
    checkAddDayButtonState();

    // Don't add first row yet - wait for dropdowns to be selected
  }

  /**
   * Check if Add Day button and Entries section should be enabled
   */
  function checkAddDayButtonState() {
    const empSelect = document.getElementById('employeeId');
    const monthSelect = document.getElementById('month');
    const yearSelect = document.getElementById('year');
    const addDayBtn = document.getElementById('addDayBtn');
    const saveBtn = document.getElementById('saveBtn');
    const overlay = document.getElementById('entriesDisabledOverlay');
    const tbody = document.getElementById('entryTableBody');

    const hasEmployee = empSelect && empSelect.value !== '';
    const hasMonth = monthSelect && monthSelect.value !== '';
    const hasYear = yearSelect && yearSelect.value !== '';

    if (hasEmployee && hasMonth && hasYear) {
      // Check for historical balance before enabling
      const employeeId = parseInt(empSelect.value);
      const month = monthSelect.value;
      const year = parseInt(yearSelect.value);

      google.script.run
        .withSuccessHandler(function(exists) {
          if (exists) {
            // Historical balance exists - show error and keep disabled
            if (addDayBtn) addDayBtn.disabled = true;
            if (saveBtn) saveBtn.disabled = true;
            if (overlay) {
              overlay.style.display = 'flex';
              overlay.innerHTML = `
                <div style="text-align: center; color: #ef4444; max-width: 500px;">
                  <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                  <p style="font-size: 1rem; font-weight: 600; margin: 0.5rem 0;">Cannot log overtime for this period</p>
                  <p style="font-size: 0.875rem; margin: 0;">A historical balance already exists for ${month} ${year}. Historical balances represent the complete COC data for that month.</p>
                </div>
              `;
            }
          } else {
            // No historical balance - enable everything
            if (addDayBtn) addDayBtn.disabled = false;
            if (saveBtn) saveBtn.disabled = false;
            if (overlay) overlay.style.display = 'none';

            // Add first row if table is empty
            if (tbody && tbody.children.length === 0) {
              addOvertimeRow();
            }
          }
        })
        .withFailureHandler(function(err) {
          console.error('Error checking historical balance:', err);
          // On error, allow proceed (fail open)
          if (addDayBtn) addDayBtn.disabled = false;
          if (saveBtn) saveBtn.disabled = false;
          if (overlay) overlay.style.display = 'none';
          if (tbody && tbody.children.length === 0) {
            addOvertimeRow();
          }
        })
        .checkHistoricalBalanceExists(employeeId, month, year);
    } else {
      // Disable buttons and show default overlay
      if (addDayBtn) addDayBtn.disabled = true;
      if (saveBtn) saveBtn.disabled = true;
      if (overlay) {
        overlay.style.display = 'flex';
        overlay.innerHTML = `
          <div style="text-align: center; color: #697386;">
            <i class="fas fa-info-circle" style="font-size: 2rem; margin-bottom: 0.5rem; color: #4f46e5;"></i>
            <p style="font-size: 1rem; font-weight: 600; margin: 0;">Please select Employee, Month, and Year first</p>
          </div>
        `;
      }
    }
  }

  /**
   * Load existing dates from database
   */
  function loadExistingDates() {
    const employeeId = document.getElementById('employeeId')?.value;
    const month = document.getElementById('month')?.value;
    const year = document.getElementById('year')?.value;

    if (!employeeId || !month || !year) {
      existingDatabaseDates = [];
      return;
    }

    google.script.run
      .withSuccessHandler(dates => {
        existingDatabaseDates = dates || [];
        console.log('Loaded existing dates:', existingDatabaseDates);
      })
      .withFailureHandler(err => {
        console.error('Error loading existing dates:', err);
        existingDatabaseDates = [];
      })
      .getExistingOvertimeDates(parseInt(employeeId), month, parseInt(year));
  }

  /**
   * Update date input constraints
   */
  function updateDateInputConstraints() {
    const month = document.getElementById('month')?.value;
    const year = document.getElementById('year')?.value;

    if (!month || !year) {
      document.querySelectorAll('.date-input').forEach(input => {
        input.removeAttribute('min');
        input.removeAttribute('max');
      });
      return;
    }

    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    const monthIndex = monthNames.indexOf(month);

    if (monthIndex === -1) return;

    const firstDay = new Date(parseInt(year), monthIndex, 1);
    const lastDay = new Date(parseInt(year), monthIndex + 1, 0);

    const minDate = formatDateForInput(firstDay);
    const maxDate = formatDateForInput(lastDay);

    document.querySelectorAll('.date-input').forEach(input => {
      input.setAttribute('min', minDate);
      input.setAttribute('max', maxDate);
    });
  }

  /**
   * Format date as YYYY-MM-DD
   */
  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  /**
   * Add a new overtime row
   */
  function addOvertimeRow() {
    rowCounter++;
    const tbody = document.getElementById('entryTableBody');
    if (!tbody) return;

    const row = document.createElement('tr');
    row.id = 'row-' + rowCounter;

    row.innerHTML = `
      <td>
        <input type="date" class="date-input" onchange="handleDateChange(${rowCounter})" required>
      </td>
      <td>
        <div class="day-type-badge day-type-weekday" id="dayType-${rowCounter}">Weekday</div>
      </td>
      <td>
        <input type="time" class="am-in" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="am-out" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="pm-in" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="pm-out" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td class="coc-earned-cell" id="hoursWorked-${rowCounter}">0.0</td>
      <td class="coc-earned-cell" id="cocEarned-${rowCounter}">0.0</td>
      <td>
        <button type="button" class="delete-row-btn" onclick="deleteOvertimeRow(${rowCounter})">
          <i class="fas fa-trash"></i>
        </button>
      </td>
    `;

    tbody.appendChild(row);
    updateDateInputConstraints();
  }

  /**
   * Delete overtime row
   */
  function deleteOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (row) {
      row.remove();
      updateGrandTotal();
    }

    const tbody = document.getElementById('entryTableBody');
    if (tbody && tbody.children.length === 0) {
      addOvertimeRow();
    }
  }

  /**
   * Handle date change with validation
   */
  function handleDateChange(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return;

    const dateInput = row.querySelector('.date-input');
    const dateValue = dateInput.value;

    if (!dateValue) {
      dateInput.classList.remove('error');
      updateOvertimeRow(rowId);
      return;
    }

    // Check server-side duplicate
    if (existingDatabaseDates.includes(dateValue)) {
      const dateObj = new Date(dateValue);
      const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

      showAlert(
        `${formattedDate} already has a COC record in the database. This date cannot be added again.`,
        'error'
      );

      dateInput.value = '';
      dateInput.classList.add('error');
      return;
    }

    // Check client-side duplicate
    const duplicateRowId = checkClientSideDuplicate(dateValue, rowId);
    if (duplicateRowId !== null) {
      const dateObj = new Date(dateValue);
      const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

      // Show modal instead of confirm dialog
      showDuplicateModal(formattedDate, duplicateRowId, rowId, dateInput);
      return;
    }

    dateInput.classList.remove('error');
    updateOvertimeRow(rowId);
  }

  /**
   * Check for client-side duplicate
   */
  function checkClientSideDuplicate(dateValue, currentRowId) {
    const rows = document.querySelectorAll('#entryTableBody tr');
    for (const row of rows) {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        if (rowId !== currentRowId) {
          const dateInput = row.querySelector('.date-input');
          if (dateInput && dateInput.value === dateValue) {
            return rowId;
          }
        }
      }
    }
    return null;
  }

  /**
   * Show duplicate entry modal
   */
  function showDuplicateModal(formattedDate, duplicateRowId, currentRowId, dateInput) {
    const modal = document.getElementById('duplicateModal');
    const message = document.getElementById('duplicateModalMessage');

    if (modal && message) {
      message.textContent = `You already have an entry for ${formattedDate} in this form. Do you want to replace the existing entry?`;

      // Store context for modal actions
      pendingDuplicateAction = {
        duplicateRowId: duplicateRowId,
        currentRowId: currentRowId,
        dateInput: dateInput
      };

      modal.style.display = 'flex';
    }
  }

  /**
   * Close duplicate entry modal
   */
  function closeDuplicateModal(shouldReplace) {
    const modal = document.getElementById('duplicateModal');

    if (modal) {
      modal.style.display = 'none';
    }

    if (pendingDuplicateAction) {
      if (shouldReplace) {
        // Replace the existing entry
        deleteOvertimeRow(pendingDuplicateAction.duplicateRowId);
        pendingDuplicateAction.dateInput.classList.remove('error');
        updateOvertimeRow(pendingDuplicateAction.currentRowId);
      } else {
        // Cancel - clear the date input
        pendingDuplicateAction.dateInput.value = '';
      }

      pendingDuplicateAction = null;
    }
  }

  /**
   * Validate and update row
   */
  function validateAndUpdateRow(rowId) {
    validateOvertimeRow(rowId);
    updateOvertimeRow(rowId);
  }

  /**
   * Update overtime row calculations
   */
  function updateOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return;

    const dateInput = row.querySelector('.date-input');
    const dayTypeDiv = document.getElementById('dayType-' + rowId);
    const hoursWorkedDiv = document.getElementById('hoursWorked-' + rowId);
    const cocEarnedDiv = document.getElementById('cocEarned-' + rowId);

    let dayType = 'Weekday';
    if (dateInput && dateInput.value) {
      const date = new Date(dateInput.value);
      const dayOfWeek = date.getDay();
      if (dayOfWeek === 0 || dayOfWeek === 6) {
        dayType = 'Weekend';
      }
      if (dayTypeDiv) {
        dayTypeDiv.textContent = dayType;
        dayTypeDiv.className = 'day-type-badge day-type-' + dayType.toLowerCase();
      }
    }

    const amIn = row.querySelector('.am-in')?.value;
    const amOut = row.querySelector('.am-out')?.value;
    const pmIn = row.querySelector('.pm-in')?.value;
    const pmOut = row.querySelector('.pm-out')?.value;

    let hoursWorked = 0;
    let cocEarned = 0;
    if (dateInput && dateInput.value && (amIn || amOut || pmIn || pmOut)) {
      const result = calculateCOC(dayType, amIn, amOut, pmIn, pmOut);
      hoursWorked = result.hoursWorked;
      cocEarned = result.cocEarned;
    }

    if (hoursWorkedDiv) hoursWorkedDiv.textContent = hoursWorked.toFixed(1);
    if (cocEarnedDiv) cocEarnedDiv.textContent = cocEarned.toFixed(1);
    updateGrandTotal();
  }

  /**
   * Calculate COC
   */
  function calculateCOC(dayType, amIn, amOut, pmIn, pmOut) {
    let totalHoursWorked = 0;
    let totalCOC = 0;

    const timeToMinutes = (timeStr) => {
      if (!timeStr) return null;
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    if (dayType === 'Weekday') {
      if (pmIn && pmOut) {
        const pmInMinutes = timeToMinutes(pmIn);
        const pmOutMinutes = timeToMinutes(pmOut);
        const windowStart = 17 * 60;
        const windowEnd = 19 * 60;
        const effectiveIn = Math.max(pmInMinutes, windowStart);
        const effectiveOut = Math.min(pmOutMinutes, windowEnd);
        if (effectiveOut > effectiveIn) {
          const hoursWorked = (effectiveOut - effectiveIn) / 60;
          totalHoursWorked = hoursWorked;
          totalCOC = Math.min(hoursWorked, 2);
        }
      }
    } else {
      if (amIn && amOut) {
        const amInMinutes = timeToMinutes(amIn);
        const amOutMinutes = timeToMinutes(amOut);
        const amWindowStart = 8 * 60;
        const amWindowEnd = 12 * 60;
        const effectiveAmIn = Math.max(amInMinutes, amWindowStart);
        const effectiveAmOut = Math.min(amOutMinutes, amWindowEnd);
        if (effectiveAmOut > effectiveAmIn) {
          const amHoursWorked = (effectiveAmOut - effectiveAmIn) / 60;
          totalHoursWorked += amHoursWorked;
          totalCOC += amHoursWorked * 1.5;
        }
      }
      if (pmIn && pmOut) {
        const pmInMinutes = timeToMinutes(pmIn);
        const pmOutMinutes = timeToMinutes(pmOut);
        const pmWindowStart = 13 * 60;
        const pmWindowEnd = 17 * 60;
        const effectivePmIn = Math.max(pmInMinutes, pmWindowStart);
        const effectivePmOut = Math.min(pmOutMinutes, pmWindowEnd);
        if (effectivePmOut > effectivePmIn) {
          const pmHoursWorked = (effectivePmOut - effectivePmIn) / 60;
          totalHoursWorked += pmHoursWorked;
          totalCOC += pmHoursWorked * 1.5;
        }
      }
    }

    return { hoursWorked: totalHoursWorked, cocEarned: totalCOC };
  }

  /**
   * Validate overtime row
   */
  function validateOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return true;

    const timeToMinutes = (timeStr) => {
      if (!timeStr) return null;
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    const validateTimeInput = (input, minTime, maxTime) => {
      if (!input || !input.value) {
        if (input) input.classList.remove('error');
        return true;
      }
      const minutes = timeToMinutes(input.value);
      const min = timeToMinutes(minTime);
      const max = timeToMinutes(maxTime);
      if (minutes < min || minutes > max) {
        input.classList.add('error');
        return false;
      }
      input.classList.remove('error');
      return true;
    };

    const amInInput = row.querySelector('.am-in');
    const amOutInput = row.querySelector('.am-out');
    const pmInInput = row.querySelector('.pm-in');
    const pmOutInput = row.querySelector('.pm-out');

    let isValid = true;

    if (amInInput && amInInput.value) {
      if (!validateTimeInput(amInInput, '05:00', '12:59')) isValid = false;
    }
    if (amOutInput && amOutInput.value) {
      if (!validateTimeInput(amOutInput, '08:00', '12:59')) isValid = false;
    }
    if (pmInInput && pmInInput.value) {
      if (!validateTimeInput(pmInInput, '12:00', '23:59')) isValid = false;
    }
    if (pmOutInput && pmOutInput.value) {
      if (!validateTimeInput(pmOutInput, '12:00', '23:59')) isValid = false;
    }

    if (amInInput && amOutInput) {
      if (amInInput.value && !amOutInput.value) {
        amOutInput.classList.add('error');
        isValid = false;
      } else if (!amInInput.value && amOutInput.value) {
        amInInput.classList.add('error');
        isValid = false;
      } else if (amInInput.value && amOutInput.value) {
        const amInMinutes = timeToMinutes(amInInput.value);
        const amOutMinutes = timeToMinutes(amOutInput.value);
        if (amOutMinutes <= amInMinutes) {
          amOutInput.classList.add('error');
          isValid = false;
        }
      }
    }

    if (pmInInput && pmOutInput) {
      if (pmInInput.value && !pmOutInput.value) {
        pmOutInput.classList.add('error');
        isValid = false;
      } else if (!pmInInput.value && pmOutInput.value) {
        pmInInput.classList.add('error');
        isValid = false;
      } else if (pmInInput.value && pmOutInput.value) {
        const pmInMinutes = timeToMinutes(pmInInput.value);
        const pmOutMinutes = timeToMinutes(pmOutInput.value);
        if (pmOutMinutes <= pmInMinutes) {
          pmOutInput.classList.add('error');
          isValid = false;
        }
      }
    }

    // Check if date is filled but ALL time inputs are empty
    const dateInput = row.querySelector('.date-input');
    if (dateInput && dateInput.value) {
      const hasAnyTime = (amInInput && amInInput.value) ||
                         (amOutInput && amOutInput.value) ||
                         (pmInInput && pmInInput.value) ||
                         (pmOutInput && pmOutInput.value);

      if (!hasAnyTime) {
        // Mark all time inputs as error to show user they need at least one
        if (amInInput) amInInput.classList.add('error');
        if (amOutInput) amOutInput.classList.add('error');
        if (pmInInput) pmInInput.classList.add('error');
        if (pmOutInput) pmOutInput.classList.add('error');
        isValid = false;
      } else {
        // If at least one time is entered, remove the "required" error from empty fields
        // (but keep errors from other validation rules like range/pair validation)
        // This is handled by the individual validateTimeInput calls above
      }
    }

    return isValid;
  }

  /**
   * Update grand total
   */
  function updateGrandTotal() {
    const rows = document.querySelectorAll('#entryTableBody tr');
    let grandTotal = 0;

    rows.forEach(row => {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        const cocEarnedDiv = document.getElementById('cocEarned-' + rowId);
        if (cocEarnedDiv) {
          const value = parseFloat(cocEarnedDiv.textContent) || 0;
          grandTotal += value;
        }
      }
    });

    const grandTotalDiv = document.getElementById('grandTotal');
    if (grandTotalDiv) {
      grandTotalDiv.textContent = grandTotal.toFixed(1) + ' hours';
    }
  }

  /**
   * Handle overtime form submission
   */
  function handleOvertimeFormSubmit(e) {
    e.preventDefault();

    const employeeId = parseInt(document.getElementById('employeeId')?.value);
    const month = document.getElementById('month')?.value;
    const year = parseInt(document.getElementById('year')?.value);

    if (!employeeId || !month || !year) {
      showAlert('Please select Employee, Month, and Year', 'error');
      return false;
    }

    const rows = document.querySelectorAll('#entryTableBody tr');
    let allRowsValid = true;

    rows.forEach(row => {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        if (!validateOvertimeRow(rowId)) {
          allRowsValid = false;
        }
      }
    });

    if (!allRowsValid) {
      showAlert('Please correct all validation errors before submitting. Check for red-highlighted fields and ensure all entries have valid times.', 'error');
      return false;
    }

    const entries = [];
    rows.forEach(row => {
      const dateInput = row.querySelector('.date-input');
      const amIn = row.querySelector('.am-in')?.value;
      const amOut = row.querySelector('.am-out')?.value;
      const pmIn = row.querySelector('.pm-in')?.value;
      const pmOut = row.querySelector('.pm-out')?.value;

      if (dateInput && dateInput.value) {
        // Check if at least one time input is filled
        const hasAnyTime = amIn || amOut || pmIn || pmOut;
        if (!hasAnyTime) {
          // Skip entries with date but no time inputs
          return;
        }

        entries.push({
          dateWorked: dateInput.value,
          amIn: formatTimeFor12Hour(amIn),
          amOut: formatTimeFor12Hour(amOut),
          pmIn: formatTimeFor12Hour(pmIn),
          pmOut: formatTimeFor12Hour(pmOut)
        });
      }
    });

    if (entries.length === 0) {
      showAlert('Please add at least one overtime entry with date and time', 'error');
      return false;
    }

    const batchData = { employeeId, month, year, entries };
    const saveBtn = document.getElementById('saveBtn');
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }

    google.script.run
      .withSuccessHandler(result => {
        if (result.success) {
          showAlert(result.message, 'success');
          setTimeout(() => resetOvertimeForm(), 2000);
        } else {
          showAlert(result.message, 'error');
        }
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Overtime Batch';
        }
      })
      .withFailureHandler(err => {
        showAlert('Error: ' + err.message, 'error');
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Overtime Batch';
        }
      })
      .saveOvertimeBatch(batchData);

    return false;
  }

  /**
   * Format time for 12-hour display
   */
  function formatTimeFor12Hour(time24) {
    if (!time24 || time24.trim() === '') return '';
    try {
      const [hours, minutes] = time24.split(':');
      let h = parseInt(hours, 10);
      const m = minutes;
      const period = h >= 12 ? 'PM' : 'AM';
      if (h === 0) h = 12;
      else if (h > 12) h -= 12;
      return `${h.toString().padStart(2, '0')}:${m} ${period}`;
    } catch (error) {
      return '';
    }
  }

  /**
   * Reset overtime form
   */
  function resetOvertimeForm() {
    const form = document.getElementById('overtimeForm');
    if (form) form.reset();

    const tbody = document.getElementById('entryTableBody');
    if (tbody) tbody.innerHTML = '';

    rowCounter = 0;
    existingDatabaseDates = [];
    duplicateContext = null;

    // Reset button and overlay state
    checkAddDayButtonState();
    updateGrandTotal();
  }

  /**
   * Load stats for Log Overtime page (deprecated)
   */
  function loadLogOvertimeStats() {
    // Deprecated - stats removed from embedded form
  }

  // ========== UNCERTIFIED REPORT PAGE ==========

  let allUncertifiedLogs = [];

  /**
   * Load uncertified report
   */
  function loadUncertifiedReport() {
    // Load stats
    loadUncertifiedReportStats();

    // Load filter dropdowns
    loadUncertifiedReportFilters();

    // Load report data
    google.script.run
      .withSuccessHandler(logs => {
        allUncertifiedLogs = logs;
        renderUncertifiedReport(logs);
      })
      .withFailureHandler(err => {
        document.getElementById('uncertifiedReportContainer').innerHTML = `
          <div style="text-align: center; padding: 3rem; color: #ef4444;">
            <i class="fas fa-exclamation-circle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
            <p>Error loading report: ${err.message}</p>
          </div>`;
      })
      .getAllUncertifiedLogs();
  }

  /**
   * Load stats for uncertified report
   */
  function loadUncertifiedReportStats() {
    google.script.run
      .withSuccessHandler(stats => {
        document.getElementById('totalUncertifiedHours').textContent = stats.totalHours.toFixed(1);
        document.getElementById('totalUncertifiedEntries').textContent = stats.totalEntries;
        document.getElementById('employeesWithUncertified').textContent = stats.employeeCount;
        document.getElementById('oldestUncertified').textContent = stats.oldestDate || '--';
      })
      .withFailureHandler(err => {
        console.error('Error loading stats:', err);
      })
      .getUncertifiedReportStats();
  }

  /**
   * Load filter dropdowns
   */
  function loadUncertifiedReportFilters() {
    // Load employees for filter
    google.script.run
      .withSuccessHandler(employees => {
        const select = document.getElementById('filterEmployee');
        if (!select) return;

        employees.forEach(emp => {
          const option = document.createElement('option');
          option.value = emp.id;
          option.textContent = emp.name;
          select.appendChild(option);
        });
      })
      .getEmployeesForDropdown();

    // Populate years (2024 to current year)
    const yearSelect = document.getElementById('filterYear');
    if (yearSelect) {
      const currentYear = new Date().getFullYear();
      for (let year = currentYear; year >= 2024; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
      }
    }
  }

  /**
   * Render uncertified report table
   */
  function renderUncertifiedReport(logs) {
    const container = document.getElementById('uncertifiedReportContainer');
    if (!container) return;

    if (logs.length === 0) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-check-circle"></i>
          <p>No uncertified logs found</p>
        </div>`;
      return;
    }

    // Group by employee
    const grouped = {};
    logs.forEach(log => {
      const key = log.employeeId;
      if (!grouped[key]) {
        grouped[key] = {
          employeeName: log.employeeName,
          logs: [],
          totalHours: 0
        };
      }
      grouped[key].logs.push(log);
      grouped[key].totalHours += log.cocEarned;
    });

    let html = '<div style="padding: 1.5rem;">';

    Object.keys(grouped).forEach(employeeId => {
      const group = grouped[employeeId];

      html += `
        <div style="margin-bottom: 2rem; border: 1px solid #e8ebed; border-radius: 8px; overflow: hidden;">
          <div style="background: #f8f9fa; padding: 1rem 1.5rem; border-bottom: 1px solid #e8ebed;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <div style="font-weight: 600; color: #1a1f36; font-size: 1rem;">${group.employeeName}</div>
                <div style="font-size: 0.875rem; color: #697386;">Employee ID: ${employeeId}</div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 0.875rem; color: #697386;">Total Uncertified</div>
                <div style="font-size: 1.25rem; font-weight: 700; color: #4f46e5;">${group.totalHours.toFixed(1)} hrs</div>
              </div>
            </div>
          </div>
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead style="background: #fafbfc;">
                <tr>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Date Worked</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Month/Year</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Day Type</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">AM In</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">AM Out</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">PM In</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">PM Out</th>
                  <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">COC Earned</th>
                </tr>
              </thead>
              <tbody>`;

      group.logs.forEach(log => {
        const dayTypeColor = log.dayType === 'Weekday' ? '#3b82f6' : (log.dayType === 'Holiday' ? '#ef4444' : '#10b981');
        html += `
          <tr style="border-bottom: 1px solid #f0f2f5;">
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.dateWorked}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.month} ${log.year}</td>
            <td style="padding: 0.75rem;">
              <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ${dayTypeColor}15; color: ${dayTypeColor};">
                ${log.dayType}
              </span>
            </td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.amIn || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.amOut || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.pmIn || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.pmOut || '--'}</td>
            <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #4f46e5; font-size: 0.875rem;">${log.cocEarned.toFixed(1)}</td>
          </tr>`;
      });

      html += `
              </tbody>
            </table>
          </div>
        </div>`;
    });

    html += '</div>';
    container.innerHTML = html;
  }

  /**
   * Filter uncertified report
   */
  function filterUncertifiedReport() {
    const employeeFilter = document.getElementById('filterEmployee').value;
    const monthFilter = document.getElementById('filterMonth').value;
    const yearFilter = document.getElementById('filterYear').value;

    let filtered = allUncertifiedLogs;

    if (employeeFilter) {
      filtered = filtered.filter(log => log.employeeId == employeeFilter);
    }

    if (monthFilter) {
      filtered = filtered.filter(log => log.month === monthFilter);
    }

    if (yearFilter) {
      filtered = filtered.filter(log => log.year == yearFilter);
    }

    renderUncertifiedReport(filtered);
  }

  /**
   * Clear filters
   */
  function clearFilters() {
    document.getElementById('filterEmployee').value = '';
    document.getElementById('filterMonth').value = '';
    document.getElementById('filterYear').value = '';
    renderUncertifiedReport(allUncertifiedLogs);
  }

  /**
   * Export to CSV
   */
  function exportToCSV() {
    if (allUncertifiedLogs.length === 0) {
      showAlert('No data to export', 'error');
      return;
    }

    let csv = 'Employee Name,Employee ID,Date Worked,Month,Year,Day Type,AM In,AM Out,PM In,PM Out,COC Earned\n';

    allUncertifiedLogs.forEach(log => {
      csv += `"${log.employeeName}",${log.employeeId},"${log.dateWorked}","${log.month}",${log.year},"${log.dayType}","${log.amIn || ''}","${log.amOut || ''}","${log.pmIn || ''}","${log.pmOut || ''}",${log.cocEarned}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `uncertified-report-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);

    showAlert('Report exported successfully', 'success');
  }

  // ========== GENERATE CERTIFICATE PAGE ==========

  /**
   * Initialize Generate Certificate form when page loads
   */
  function initGenerateCertificateForm() {
    // Populate years
    const yearSelect = document.getElementById('certYear');
    if (yearSelect) {
      const currentYear = new Date().getFullYear();
      for (let i = 0; i <= 2; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (i === 0) option.selected = true;
        yearSelect.appendChild(option);
      }
    }

    // Load employees
    google.script.run
      .withSuccessHandler(employees => {
        const empSelect = document.getElementById('certEmployeeId');
        if (empSelect) {
          employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = emp.name;
            empSelect.appendChild(option);
          });
        }
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();

    // Add event listeners
    const empSelect = document.getElementById('certEmployeeId');
    const monthSelect = document.getElementById('certMonth');
    const yearSelectElem = document.getElementById('certYear');
    const dateOfIssuance = document.getElementById('dateOfIssuance');

    if (empSelect) {
      empSelect.addEventListener('change', loadUncertifiedHours);
    }
    if (monthSelect) {
      monthSelect.addEventListener('change', loadUncertifiedHours);
    }
    if (yearSelectElem) {
      yearSelectElem.addEventListener('change', loadUncertifiedHours);
    }
    if (dateOfIssuance) {
      dateOfIssuance.addEventListener('change', updateValidUntilDisplay);
    }
  }

  /**
   * Load uncertified hours for selected employee/month/year
   */
  function loadUncertifiedHours() {
    const employeeId = document.getElementById('certEmployeeId')?.value;
    const month = document.getElementById('certMonth')?.value;
    const year = document.getElementById('certYear')?.value;

    const summary = document.getElementById('uncertifiedSummary');
    const hoursDisplay = document.getElementById('uncertifiedHours');
    const noDataMessage = document.getElementById('noUncertifiedMessage');
    const generateBtn = document.getElementById('generateCertBtn');

    if (!employeeId || !month || !year) {
      if (summary) summary.style.display = 'none';
      if (generateBtn) generateBtn.disabled = true;
      return;
    }

    // Show loading state
    if (summary) summary.style.display = 'block';
    if (hoursDisplay) hoursDisplay.textContent = 'Loading...';
    if (noDataMessage) noDataMessage.style.display = 'none';
    if (generateBtn) generateBtn.disabled = true;

    // Fetch uncertified hours from server
    google.script.run
      .withSuccessHandler(result => {
        if (result.hours > 0) {
          if (hoursDisplay) hoursDisplay.textContent = result.hours.toFixed(1) + ' hrs';
          if (noDataMessage) noDataMessage.style.display = 'none';

          // Update Valid Until display
          updateValidUntilDisplay();

          // Enable button if date of issuance is set
          const dateOfIssuance = document.getElementById('dateOfIssuance')?.value;
          if (generateBtn && dateOfIssuance) {
            generateBtn.disabled = false;
          }
        } else {
          if (hoursDisplay) hoursDisplay.textContent = '0.0 hrs';
          if (noDataMessage) noDataMessage.style.display = 'block';
          if (generateBtn) generateBtn.disabled = true;
        }
      })
      .withFailureHandler(err => {
        console.error('Error loading uncertified hours:', err);
        if (hoursDisplay) hoursDisplay.textContent = 'Error';
        showAlert('Error loading uncertified hours: ' + err.message, 'error');
      })
      .getUncertifiedHours(parseInt(employeeId), month, parseInt(year));
  }

  /**
   * Update Valid Until date display based on Date of Issuance
   */
  function updateValidUntilDisplay() {
    const dateOfIssuance = document.getElementById('dateOfIssuance')?.value;
    const validUntilDisplay = document.getElementById('validUntilDate');
    const generateBtn = document.getElementById('generateCertBtn');
    const hoursDisplay = document.getElementById('uncertifiedHours');

    if (!dateOfIssuance || !validUntilDisplay) return;

    // Calculate Valid Until: (Date of Issuance + 1 Year - 1 Day)
    const issuanceDate = new Date(dateOfIssuance);
    const validUntil = new Date(issuanceDate);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);

    // Format date as MM/DD/YYYY
    const formattedDate = (validUntil.getMonth() + 1).toString().padStart(2, '0') + '/' +
                          validUntil.getDate().toString().padStart(2, '0') + '/' +
                          validUntil.getFullYear();

    validUntilDisplay.textContent = formattedDate;

    // Enable button if we have hours
    const hasHours = hoursDisplay && hoursDisplay.textContent !== '0.0 hrs' &&
                     hoursDisplay.textContent !== 'Loading...' &&
                     hoursDisplay.textContent !== 'Error';
    if (generateBtn && hasHours) {
      generateBtn.disabled = false;
    }
  }

  /**
   * Handle certificate form submission
   */
  function handleCertificateFormSubmit(e) {
    e.preventDefault();

    const employeeId = parseInt(document.getElementById('certEmployeeId')?.value);
    const month = document.getElementById('certMonth')?.value;
    const year = parseInt(document.getElementById('certYear')?.value);
    const dateOfIssuance = document.getElementById('dateOfIssuance')?.value;

    if (!employeeId || !month || !year || !dateOfIssuance) {
      showAlert('Please fill in all required fields', 'error');
      return false;
    }

    const generateBtn = document.getElementById('generateCertBtn');
    if (generateBtn) {
      generateBtn.disabled = true;
      generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
    }

    const certificateData = {
      employeeId: employeeId,
      month: month,
      year: year,
      dateOfIssuance: dateOfIssuance
    };

    google.script.run
      .withSuccessHandler(result => {
        if (result.success) {
          showAlert(result.message, 'success');
          setTimeout(() => resetCertificateForm(), 2000);
        } else {
          showAlert(result.message, 'error');
        }
        if (generateBtn) {
          generateBtn.disabled = false;
          generateBtn.innerHTML = '<i class="fas fa-certificate"></i> Generate Certificate';
        }
      })
      .withFailureHandler(err => {
        showAlert('Error generating certificate: ' + err.message, 'error');
        if (generateBtn) {
          generateBtn.disabled = false;
          generateBtn.innerHTML = '<i class="fas fa-certificate"></i> Generate Certificate';
        }
      })
      .generateCOCCertificate(certificateData);

    return false;
  }

  /**
   * Reset certificate form
   */
  function resetCertificateForm() {
    const form = document.getElementById('certificateForm');
    if (form) form.reset();

    const summary = document.getElementById('uncertifiedSummary');
    if (summary) summary.style.display = 'none';

    const generateBtn = document.getElementById('generateCertBtn');
    if (generateBtn) {
      generateBtn.disabled = true;
      generateBtn.innerHTML = '<i class="fas fa-certificate"></i> Generate Certificate';
    }

    const validUntilDisplay = document.getElementById('validUntilDate');
    if (validUntilDisplay) validUntilDisplay.textContent = '--';
  }

  // ========== EMPLOYEE LEDGER PAGE ==========

  /**
   * Initialize Employee Ledger form when page loads
   */
  function initEmployeeLedgerForm() {
    console.log('initEmployeeLedgerForm called');

    // Load employees into dropdown
    google.script.run
      .withSuccessHandler(employees => {
        console.log('Employees loaded:', employees.length);
        const dropdown = document.getElementById('ledgerEmployeeDropdown');
        if (dropdown) {
          // Clear existing options except first
          dropdown.innerHTML = '<option value="">-- Select Employee --</option>';

          // Add employee options
          employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = `${emp.name} (ID: ${emp.id})`;
            option.dataset.employeeData = JSON.stringify({
              employeeId: emp.id,
              firstName: emp.firstName,
              middleInitial: emp.middleInitial,
              lastName: emp.lastName
            });
            dropdown.appendChild(option);
          });
        }
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();

    // Add change listener to dropdown
    const dropdown = document.getElementById('ledgerEmployeeDropdown');
    if (dropdown) {
      dropdown.addEventListener('change', loadSelectedEmployeeLedger);
    }
  }

  /**
   * Load ledger for selected employee from dropdown
   */
  function loadSelectedEmployeeLedger() {
    const dropdown = document.getElementById('ledgerEmployeeDropdown');
    const employeeId = dropdown?.value;

    if (!employeeId) {
      // No employee selected - show empty state
      const ledgerContent = document.getElementById('ledgerContent');
      const ledgerEmptyState = document.getElementById('ledgerEmptyState');
      if (ledgerContent) ledgerContent.style.display = 'none';
      if (ledgerEmptyState) ledgerEmptyState.style.display = 'block';
      return;
    }

    // Get employee data from selected option
    const selectedOption = dropdown.options[dropdown.selectedIndex];
    const employeeData = selectedOption.dataset.employeeData ? JSON.parse(selectedOption.dataset.employeeData) : null;

    console.log('Loading ledger for employee:', employeeId, employeeData);

    const ledgerContent = document.getElementById('ledgerContent');
    const ledgerEmptyState = document.getElementById('ledgerEmptyState');
    const ledgerTableContainer = document.getElementById('ledgerTableContainer');

    // Show loading state
    if (ledgerContent) ledgerContent.style.display = 'block';
    if (ledgerEmptyState) ledgerEmptyState.style.display = 'none';
    if (ledgerTableContainer) {
      ledgerTableContainer.innerHTML = '<div class="empty-state"><i class="fas fa-spinner fa-spin"></i><p>Loading ledger...</p></div>';
    }

    // Fetch ledger data
    google.script.run
      .withSuccessHandler(ledgerData => {
        console.log('Ledger data received:', ledgerData);
        if (!ledgerData) {
          console.error('ledgerData is null or undefined');
        }
        renderEmployeeLedgerData(ledgerData, employeeData);
      })
      .withFailureHandler(err => {
        console.error('Error loading ledger:', err);
        showAlert('Error loading ledger: ' + err.message, 'error');
        if (ledgerTableContainer) {
          ledgerTableContainer.innerHTML = `
            <div class="empty-state">
              <i class="fas fa-exclamation-triangle"></i>
              <p>Error loading ledger</p>
            </div>`;
        }
      })
      .getEmployeeLedgerDetailed(parseInt(employeeId));
  }

  /**
   * Render ledger data to the page
   */
  function renderEmployeeLedgerData(ledgerData, employee) {
    // Null check
    if (!ledgerData) {
      console.error('renderEmployeeLedgerData: ledgerData is null or undefined');
      console.error('Employee object:', employee);
      showAlert('Error: Failed to load ledger data', 'error');

      // Hide loading and show error
      const ledgerContent = document.getElementById('ledgerContent');
      const ledgerEmptyState = document.getElementById('ledgerEmptyState');
      if (ledgerContent) ledgerContent.style.display = 'none';
      if (ledgerEmptyState) {
        ledgerEmptyState.style.display = 'block';
        ledgerEmptyState.innerHTML = `
          <div style="text-align: center; padding: 3rem;">
            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #ef4444; margin-bottom: 1rem;"></i>
            <p style="color: #697386;">Failed to load ledger data. Please try again.</p>
          </div>
        `;
      }
      return;
    }

    // Display employee info
    const employeeNameDisplay = document.getElementById('employeeNameDisplay');
    const employeeIdDisplay = document.getElementById('employeeIdDisplay');

    if (employee && employeeNameDisplay && employeeIdDisplay) {
      const fullName = `${employee.firstName || ''} ${employee.middleInitial ? employee.middleInitial + '.' : ''} ${employee.lastName || ''}`.trim();
      employeeNameDisplay.textContent = fullName;
      employeeIdDisplay.textContent = `Employee ID: ${employee.employeeId}`;
    }

    // Update balance displays
    const activeBalanceDisplay = document.getElementById('activeBalanceDisplay');
    const uncertifiedBalanceDisplay = document.getElementById('uncertifiedBalanceDisplay');
    const totalEarnedDisplay = document.getElementById('totalEarnedDisplay');
    const usedCOCsDisplay = document.getElementById('usedCOCsDisplay');

    if (activeBalanceDisplay) activeBalanceDisplay.textContent = (ledgerData.activeBalance || 0).toFixed(1) + ' hrs';
    if (uncertifiedBalanceDisplay) uncertifiedBalanceDisplay.textContent = (ledgerData.uncertifiedBalance || 0).toFixed(1) + ' hrs';
    if (totalEarnedDisplay) totalEarnedDisplay.textContent = (ledgerData.totalEarned || 0).toFixed(1) + ' hrs';
    if (usedCOCsDisplay) usedCOCsDisplay.textContent = (ledgerData.usedCOCs || 0).toFixed(1) + ' hrs';

    // Separate historical data from current transactions
    const transactions = ledgerData.transactions || [];
    const historicalData = transactions.filter(tx => tx.isHistorical);
    const currentTransactions = transactions.filter(tx => !tx.isHistorical);

    // ========================================
    // PART 1: Render Beginning Balance (Historical Data)
    // ========================================
    const beginningBalanceSection = document.getElementById('beginningBalanceSection');
    const beginningBalanceContainer = document.getElementById('beginningBalanceContainer');

    if (historicalData.length > 0) {
      if (beginningBalanceSection) beginningBalanceSection.style.display = 'block';

      if (beginningBalanceContainer) {
        let historicalRows = '';
        let totalHistoricalEarned = 0;
        let totalHistoricalRemaining = 0;

        historicalData.forEach(tx => {
          const statusColors = {
            'Active': '#10b981',
            'Used': '#6b7280',
            'Expired': '#ef4444'
          };
          const statusColor = statusColors[tx.status] || '#6b7280';

          const validUntilDisplay = tx.validUntil
            ? new Date(tx.validUntil).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
            : '--';

          totalHistoricalEarned += tx.cocEarned;

          historicalRows += `
            <tr style="border-bottom: 1px solid #e1e4e8;">
              <td style="padding: 0.75rem; font-size: 0.875rem;">${tx.month} ${tx.year}</td>
              <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #10b981; font-size: 0.875rem;">${tx.cocEarned.toFixed(1)} hrs</td>
              <td style="padding: 0.75rem; text-align: center; font-size: 0.875rem;">${validUntilDisplay}</td>
              <td style="padding: 0.75rem; text-align: center;">
                <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ${statusColor}15; color: ${statusColor};">
                  ${tx.status}
                </span>
              </td>
            </tr>
          `;
        });

        beginningBalanceContainer.innerHTML = `
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead style="background: #f6f8fa;">
                <tr>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Period</th>
                  <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">COC Earned</th>
                  <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Valid Until</th>
                  <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Status</th>
                </tr>
              </thead>
              <tbody>
                ${historicalRows}
              </tbody>
            </table>
          </div>
          <div style="margin-top: 1rem; padding: 1rem; background: white; border-radius: 6px; border: 1px solid #e1e4e8;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 600; color: #1a1f36;">Total Historical Balance:</span>
              <span style="font-size: 1.25rem; font-weight: 700; color: #4f46e5;">${totalHistoricalEarned.toFixed(1)} hrs</span>
            </div>
          </div>
        `;
      }
    } else {
      if (beginningBalanceSection) beginningBalanceSection.style.display = 'none';
    }

    // ========================================
    // PART 2: Render COC Ledger (Current Transactions)
    // ========================================
    const ledgerTableContainer = document.getElementById('ledgerTableContainer');
    if (!ledgerTableContainer) return;

    if (currentTransactions.length === 0) {
      ledgerTableContainer.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-info-circle"></i>
          <p>No transactions found</p>
        </div>`;
      return;
    }

    // Build ledger table with running balance
    let ledgerRows = '';
    let runningBalance = 0;

    // Sort by date (oldest first for proper running balance calculation)
    const sortedTransactions = [...currentTransactions].sort((a, b) => {
      const dateA = new Date(a.dateWorked);
      const dateB = new Date(b.dateWorked);
      return dateA - dateB;
    });

    sortedTransactions.forEach(tx => {
      // Determine transaction type
      let particular = '';
      let cocEarned = 0;
      let cocUsed = 0;
      let dateOfCTO = '--';

      if (tx.status === 'Uncertified' || tx.status === 'Active' || tx.status === 'Expired') {
        // This is an "Earned" transaction
        particular = `Overtime - ${tx.dayType} (${tx.month} ${tx.year})`;
        cocEarned = tx.cocEarned;
        runningBalance += cocEarned;
      } else if (tx.status === 'Used') {
        // This is a "Used" transaction (future CTO usage)
        particular = `CTO Used`;
        cocUsed = tx.cocEarned; // For CTO, this would be negative
        runningBalance -= cocUsed;
        dateOfCTO = tx.dateWorked;
      }

      const statusColors = {
        'Active': '#10b981',
        'Uncertified': '#f59e0b',
        'Used': '#6b7280',
        'Expired': '#ef4444'
      };
      const statusColor = statusColors[tx.status] || '#6b7280';

      ledgerRows += `
        <tr style="border-bottom: 1px solid #f0f2f5;">
          <td style="padding: 0.75rem; font-size: 0.875rem;">
            <div style="font-weight: 500; color: #1a1f36;">${particular}</div>
            <div style="font-size: 0.75rem; color: #697386; margin-top: 0.25rem;">${tx.dateWorked}</div>
          </td>
          <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #10b981; font-size: 0.875rem;">
            ${cocEarned > 0 ? '+' + cocEarned.toFixed(1) : '--'}
          </td>
          <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #ef4444; font-size: 0.875rem;">
            ${cocUsed > 0 ? '-' + cocUsed.toFixed(1) : '--'}
          </td>
          <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #4f46e5; font-size: 0.875rem;">
            ${runningBalance.toFixed(1)}
          </td>
          <td style="padding: 0.75rem; text-align: center; font-size: 0.875rem;">
            ${dateOfCTO}
          </td>
          <td style="padding: 0.75rem; text-align: center;">
            <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ${statusColor}15; color: ${statusColor};">
              ${tx.status}
            </span>
          </td>
        </tr>
      `;
    });

    const ledgerTable = `
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; background: white; border: 1px solid #e1e4e8; border-radius: 8px;">
          <thead style="background: #fafbfc;">
            <tr>
              <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Particular</th>
              <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">COC Earned</th>
              <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Used COCs</th>
              <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Remaining COCs</th>
              <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Date of CTO</th>
              <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Status</th>
            </tr>
          </thead>
          <tbody>
            ${ledgerRows}
          </tbody>
        </table>
      </div>
    `;

    ledgerTableContainer.innerHTML = ledgerTable;
  }

  // ========== AUTO-LOAD ON PAGE CHANGE ==========

  // Note: Both initLogOvertimeForm() and loadUncertifiedReport() are now called
  // from their respective view loaders in Main after HTML is fully loaded
</script>

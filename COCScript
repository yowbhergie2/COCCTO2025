<script>
  // ========== LOG OVERTIME PAGE ==========

  let rowCounter = 0;
  let existingDatabaseDates = [];
  let duplicateContext = null;
  let pendingDuplicateAction = null;

  /**
   * Initialize Log Overtime form when page loads
   */
  function initLogOvertimeForm() {
    // Populate years (only current year and past years)
    const yearSelect = document.getElementById('year');
    if (yearSelect) {
      const currentYear = new Date().getFullYear();
      for (let i = 0; i <= 2; i++) {
        const year = currentYear - i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (i === 0) option.selected = true;
        yearSelect.appendChild(option);
      }
    }

    // Load employees
    google.script.run
      .withSuccessHandler(employees => {
        const empSelect = document.getElementById('employeeId');
        if (empSelect) {
          employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = emp.id;
            option.textContent = emp.name;
            empSelect.appendChild(option);
          });
        }
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();

    // Add event listeners
    const empSelect = document.getElementById('employeeId');
    const monthSelect = document.getElementById('month');
    const yearSelectElem = document.getElementById('year');

    if (empSelect) {
      empSelect.addEventListener('change', () => {
        loadExistingDates();
        checkAddDayButtonState();
      });
    }
    if (monthSelect) {
      monthSelect.addEventListener('change', () => {
        loadExistingDates();
        updateDateInputConstraints();
        checkAddDayButtonState();
      });
    }
    if (yearSelectElem) {
      yearSelectElem.addEventListener('change', () => {
        updateMonthOptionsForYear();
        loadExistingDates();
        updateDateInputConstraints();
        checkAddDayButtonState();
      });
    }

    // Initial setup: disable future months for current year
    updateMonthOptionsForYear();

    // Initial button and entries state check
    checkAddDayButtonState();

    // Don't add first row yet - wait for dropdowns to be selected
  }

  /**
   * Update month dropdown options based on selected year
   * Disable future months for current year
   */
  function updateMonthOptionsForYear() {
    const yearSelect = document.getElementById('year');
    const monthSelect = document.getElementById('month');

    if (!yearSelect || !monthSelect) return;

    const selectedYear = parseInt(yearSelect.value);
    if (!selectedYear) return;

    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth(); // 0-11

    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];

    const selectedMonth = monthSelect.value;

    // Enable/disable months based on whether it's the current year
    const options = monthSelect.querySelectorAll('option');
    options.forEach(option => {
      if (option.value === '') return; // Skip the placeholder option

      const monthIndex = monthNames.indexOf(option.value);
      if (monthIndex === -1) return;

      // If current year, disable future months
      if (selectedYear === currentYear && monthIndex > currentMonth) {
        option.disabled = true;
        option.textContent = option.value + ' (Future)';

        // If currently selected month is now disabled, clear selection
        if (option.value === selectedMonth) {
          monthSelect.value = '';
        }
      } else {
        option.disabled = false;
        option.textContent = option.value;
      }
    });
  }

  /**
   * Check if Add Day button and Entries section should be enabled
   */
  function checkAddDayButtonState() {
    const empSelect = document.getElementById('employeeId');
    const monthSelect = document.getElementById('month');
    const yearSelect = document.getElementById('year');
    const addDayBtn = document.getElementById('addDayBtn');
    const saveBtn = document.getElementById('saveBtn');
    const overlay = document.getElementById('entriesDisabledOverlay');
    const tbody = document.getElementById('entryTableBody');

    const hasEmployee = empSelect && empSelect.value !== '';
    const hasMonth = monthSelect && monthSelect.value !== '';
    const hasYear = yearSelect && yearSelect.value !== '';

    if (hasEmployee && hasMonth && hasYear) {
      // Check for historical balance before enabling
      const employeeId = parseInt(empSelect.value);
      const month = monthSelect.value;
      const year = parseInt(yearSelect.value);

      google.script.run
        .withSuccessHandler(function(exists) {
          if (exists) {
            // Historical balance exists - show error and keep disabled
            if (addDayBtn) addDayBtn.disabled = true;
            if (saveBtn) saveBtn.disabled = true;
            if (overlay) {
              overlay.style.display = 'flex';
              overlay.innerHTML = `
                <div style="text-align: center; color: #ef4444; max-width: 500px;">
                  <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                  <p style="font-size: 1rem; font-weight: 600; margin: 0.5rem 0;">Cannot log overtime for this period</p>
                  <p style="font-size: 0.875rem; margin: 0;">A historical balance already exists for ${month} ${year}. Historical balances represent the complete COC data for that month.</p>
                </div>
              `;
            }
          } else {
            // No historical balance - enable everything
            if (addDayBtn) addDayBtn.disabled = false;
            if (saveBtn) saveBtn.disabled = false;
            if (overlay) overlay.style.display = 'none';

            // Add first row if table is empty
            if (tbody && tbody.children.length === 0) {
              addOvertimeRow();
            }
          }
        })
        .withFailureHandler(function(err) {
          console.error('Error checking historical balance:', err);
          // On error, allow proceed (fail open)
          if (addDayBtn) addDayBtn.disabled = false;
          if (saveBtn) saveBtn.disabled = false;
          if (overlay) overlay.style.display = 'none';
          if (tbody && tbody.children.length === 0) {
            addOvertimeRow();
          }
        })
        .checkHistoricalBalanceExists(employeeId, month, year);
    } else {
      // Disable buttons and show default overlay
      if (addDayBtn) addDayBtn.disabled = true;
      if (saveBtn) saveBtn.disabled = true;
      if (overlay) {
        overlay.style.display = 'flex';
        overlay.innerHTML = `
          <div style="text-align: center; color: #697386;">
            <i class="fas fa-info-circle" style="font-size: 2rem; margin-bottom: 0.5rem; color: #4f46e5;"></i>
            <p style="font-size: 1rem; font-weight: 600; margin: 0;">Please select Employee, Month, and Year first</p>
          </div>
        `;
      }
    }
  }

  /**
   * Load existing dates from database
   */
  function loadExistingDates() {
    const employeeId = document.getElementById('employeeId')?.value;
    const month = document.getElementById('month')?.value;
    const year = document.getElementById('year')?.value;

    if (!employeeId || !month || !year) {
      existingDatabaseDates = [];
      return;
    }

    google.script.run
      .withSuccessHandler(dates => {
        existingDatabaseDates = dates || [];
        console.log('Loaded existing dates:', existingDatabaseDates);
      })
      .withFailureHandler(err => {
        console.error('Error loading existing dates:', err);
        existingDatabaseDates = [];
      })
      .getExistingOvertimeDates(parseInt(employeeId), month, parseInt(year));
  }

  /**
   * Update date input constraints
   */
  function updateDateInputConstraints() {
    const month = document.getElementById('month')?.value;
    const year = document.getElementById('year')?.value;

    if (!month || !year) {
      document.querySelectorAll('.date-input').forEach(input => {
        input.removeAttribute('min');
        input.removeAttribute('max');
      });
      return;
    }

    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                        'July', 'August', 'September', 'October', 'November', 'December'];
    const monthIndex = monthNames.indexOf(month);

    if (monthIndex === -1) return;

    const firstDay = new Date(parseInt(year), monthIndex, 1);
    const lastDay = new Date(parseInt(year), monthIndex + 1, 0);

    const minDate = formatDateForInput(firstDay);
    const maxDate = formatDateForInput(lastDay);

    document.querySelectorAll('.date-input').forEach(input => {
      input.setAttribute('min', minDate);
      input.setAttribute('max', maxDate);
    });
  }

  /**
   * Format date as YYYY-MM-DD
   */
  function formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  /**
   * Add a new overtime row
   */
  function addOvertimeRow() {
    rowCounter++;
    const tbody = document.getElementById('entryTableBody');
    if (!tbody) return;

    const row = document.createElement('tr');
    row.id = 'row-' + rowCounter;

    row.innerHTML = `
      <td>
        <input type="date" class="date-input" onchange="handleDateChange(${rowCounter})" required>
      </td>
      <td>
        <div class="day-type-badge day-type-weekday" id="dayType-${rowCounter}">Weekday</div>
      </td>
      <td>
        <input type="time" class="am-in" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="am-out" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="pm-in" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td>
        <input type="time" class="pm-out" oninput="validateAndUpdateRow(${rowCounter})">
      </td>
      <td class="coc-earned-cell" id="hoursWorked-${rowCounter}">0.0</td>
      <td class="coc-earned-cell" id="cocEarned-${rowCounter}">0.0</td>
      <td>
        <button type="button" class="delete-row-btn" onclick="deleteOvertimeRow(${rowCounter})">
          <i class="fas fa-trash"></i>
        </button>
      </td>
    `;

    tbody.appendChild(row);
    updateDateInputConstraints();
  }

  /**
   * Delete overtime row
   */
  function deleteOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (row) {
      row.remove();
      updateGrandTotal();
    }

    const tbody = document.getElementById('entryTableBody');
    if (tbody && tbody.children.length === 0) {
      addOvertimeRow();
    }
  }

  /**
   * Handle date change with validation
   */
  function handleDateChange(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return;

    const dateInput = row.querySelector('.date-input');
    const dateValue = dateInput.value;

    if (!dateValue) {
      dateInput.classList.remove('error');
      updateOvertimeRow(rowId);
      return;
    }

    // Check server-side duplicate
    if (existingDatabaseDates.includes(dateValue)) {
      const dateObj = new Date(dateValue);
      const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

      showAlert(
        `${formattedDate} already has a COC record in the database. This date cannot be added again.`,
        'error'
      );

      dateInput.value = '';
      dateInput.classList.add('error');
      return;
    }

    // Check client-side duplicate
    const duplicateRowId = checkClientSideDuplicate(dateValue, rowId);
    if (duplicateRowId !== null) {
      const dateObj = new Date(dateValue);
      const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

      // Show modal instead of confirm dialog
      showDuplicateModal(formattedDate, duplicateRowId, rowId, dateInput);
      return;
    }

    dateInput.classList.remove('error');
    updateOvertimeRow(rowId);
  }

  /**
   * Check for client-side duplicate
   */
  function checkClientSideDuplicate(dateValue, currentRowId) {
    const rows = document.querySelectorAll('#entryTableBody tr');
    for (const row of rows) {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        if (rowId !== currentRowId) {
          const dateInput = row.querySelector('.date-input');
          if (dateInput && dateInput.value === dateValue) {
            return rowId;
          }
        }
      }
    }
    return null;
  }

  /**
   * Show duplicate entry modal
   */
  function showDuplicateModal(formattedDate, duplicateRowId, currentRowId, dateInput) {
    const modal = document.getElementById('duplicateModal');
    const message = document.getElementById('duplicateModalMessage');

    if (modal && message) {
      message.textContent = `You already have an entry for ${formattedDate} in this form. Do you want to replace the existing entry?`;

      // Store context for modal actions
      pendingDuplicateAction = {
        duplicateRowId: duplicateRowId,
        currentRowId: currentRowId,
        dateInput: dateInput
      };

      modal.style.display = 'flex';
    }
  }

  /**
   * Close duplicate entry modal
   */
  function closeDuplicateModal(shouldReplace) {
    const modal = document.getElementById('duplicateModal');

    if (modal) {
      modal.style.display = 'none';
    }

    if (pendingDuplicateAction) {
      if (shouldReplace) {
        // Replace the existing entry
        deleteOvertimeRow(pendingDuplicateAction.duplicateRowId);
        pendingDuplicateAction.dateInput.classList.remove('error');
        updateOvertimeRow(pendingDuplicateAction.currentRowId);
      } else {
        // Cancel - clear the date input
        pendingDuplicateAction.dateInput.value = '';
      }

      pendingDuplicateAction = null;
    }
  }

  /**
   * Validate and update row
   */
  function validateAndUpdateRow(rowId) {
    validateOvertimeRow(rowId);
    updateOvertimeRow(rowId);
  }

  /**
   * Update overtime row calculations
   */
  function updateOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return;

    const dateInput = row.querySelector('.date-input');
    const dayTypeDiv = document.getElementById('dayType-' + rowId);
    const hoursWorkedDiv = document.getElementById('hoursWorked-' + rowId);
    const cocEarnedDiv = document.getElementById('cocEarned-' + rowId);

    let dayType = 'Weekday';
    if (dateInput && dateInput.value) {
      const date = new Date(dateInput.value);
      const dayOfWeek = date.getDay();
      if (dayOfWeek === 0 || dayOfWeek === 6) {
        dayType = 'Weekend';
      }
      if (dayTypeDiv) {
        dayTypeDiv.textContent = dayType;
        dayTypeDiv.className = 'day-type-badge day-type-' + dayType.toLowerCase();
      }
    }

    const amIn = row.querySelector('.am-in')?.value;
    const amOut = row.querySelector('.am-out')?.value;
    const pmIn = row.querySelector('.pm-in')?.value;
    const pmOut = row.querySelector('.pm-out')?.value;

    let hoursWorked = 0;
    let cocEarned = 0;
    if (dateInput && dateInput.value && (amIn || amOut || pmIn || pmOut)) {
      const result = calculateCOC(dayType, amIn, amOut, pmIn, pmOut);
      hoursWorked = result.hoursWorked;
      cocEarned = result.cocEarned;
    }

    if (hoursWorkedDiv) hoursWorkedDiv.textContent = hoursWorked.toFixed(1);
    if (cocEarnedDiv) cocEarnedDiv.textContent = cocEarned.toFixed(1);
    updateGrandTotal();
  }

  /**
   * Calculate COC
   */
  function calculateCOC(dayType, amIn, amOut, pmIn, pmOut) {
    let totalHoursWorked = 0;
    let totalCOC = 0;

    const timeToMinutes = (timeStr) => {
      if (!timeStr) return null;
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    if (dayType === 'Weekday') {
      if (pmIn && pmOut) {
        const pmInMinutes = timeToMinutes(pmIn);
        const pmOutMinutes = timeToMinutes(pmOut);
        const windowStart = 17 * 60;
        const windowEnd = 19 * 60;
        const effectiveIn = Math.max(pmInMinutes, windowStart);
        const effectiveOut = Math.min(pmOutMinutes, windowEnd);
        if (effectiveOut > effectiveIn) {
          const hoursWorked = (effectiveOut - effectiveIn) / 60;
          totalHoursWorked = hoursWorked;
          totalCOC = Math.min(hoursWorked, 2);
        }
      }
    } else {
      if (amIn && amOut) {
        const amInMinutes = timeToMinutes(amIn);
        const amOutMinutes = timeToMinutes(amOut);
        const amWindowStart = 8 * 60;
        const amWindowEnd = 12 * 60;
        const effectiveAmIn = Math.max(amInMinutes, amWindowStart);
        const effectiveAmOut = Math.min(amOutMinutes, amWindowEnd);
        if (effectiveAmOut > effectiveAmIn) {
          const amHoursWorked = (effectiveAmOut - effectiveAmIn) / 60;
          totalHoursWorked += amHoursWorked;
          totalCOC += amHoursWorked * 1.5;
        }
      }
      if (pmIn && pmOut) {
        const pmInMinutes = timeToMinutes(pmIn);
        const pmOutMinutes = timeToMinutes(pmOut);
        const pmWindowStart = 13 * 60;
        const pmWindowEnd = 17 * 60;
        const effectivePmIn = Math.max(pmInMinutes, pmWindowStart);
        const effectivePmOut = Math.min(pmOutMinutes, pmWindowEnd);
        if (effectivePmOut > effectivePmIn) {
          const pmHoursWorked = (effectivePmOut - effectivePmIn) / 60;
          totalHoursWorked += pmHoursWorked;
          totalCOC += pmHoursWorked * 1.5;
        }
      }
    }

    return { hoursWorked: totalHoursWorked, cocEarned: totalCOC };
  }

  /**
   * Validate overtime row
   */
  /**
   * Validate overtime row and collect error messages
   * @param {number} rowId - The row ID to validate
   * @returns {Object} { isValid: boolean, errors: string[] }
   */
  function validateOvertimeRow(rowId) {
    const row = document.getElementById('row-' + rowId);
    if (!row) return { isValid: true, errors: [] };

    const errors = [];

    const timeToMinutes = (timeStr) => {
      if (!timeStr) return null;
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    const validateTimeInput = (input, minTime, maxTime) => {
      if (!input || !input.value) {
        if (input) input.classList.remove('error');
        return true;
      }
      const minutes = timeToMinutes(input.value);
      const min = timeToMinutes(minTime);
      const max = timeToMinutes(maxTime);
      if (minutes < min || minutes > max) {
        input.classList.add('error');
        return false;
      }
      input.classList.remove('error');
      return true;
    };

    const amInInput = row.querySelector('.am-in');
    const amOutInput = row.querySelector('.am-out');
    const pmInInput = row.querySelector('.pm-in');
    const pmOutInput = row.querySelector('.pm-out');

    let isValid = true;

    if (amInInput && amInInput.value) {
      if (!validateTimeInput(amInInput, '05:00', '12:59')) {
        errors.push('AM In must be between 5:00 AM and 12:59 PM');
        isValid = false;
      }
    }
    if (amOutInput && amOutInput.value) {
      if (!validateTimeInput(amOutInput, '08:00', '12:59')) {
        errors.push('AM Out must be between 8:00 AM and 12:59 PM');
        isValid = false;
      }
    }
    if (pmInInput && pmInInput.value) {
      if (!validateTimeInput(pmInInput, '12:00', '23:59')) {
        errors.push('PM In must be between 12:00 PM and 11:59 PM');
        isValid = false;
      }
    }
    if (pmOutInput && pmOutInput.value) {
      if (!validateTimeInput(pmOutInput, '12:00', '23:59')) {
        errors.push('PM Out must be between 12:00 PM and 11:59 PM');
        isValid = false;
      }
    }

    if (amInInput && amOutInput) {
      if (amInInput.value && !amOutInput.value) {
        amOutInput.classList.add('error');
        errors.push('AM Out is required when AM In is entered');
        isValid = false;
      } else if (!amInInput.value && amOutInput.value) {
        amInInput.classList.add('error');
        errors.push('AM In is required when AM Out is entered');
        isValid = false;
      } else if (amInInput.value && amOutInput.value) {
        const amInMinutes = timeToMinutes(amInInput.value);
        const amOutMinutes = timeToMinutes(amOutInput.value);
        if (amOutMinutes <= amInMinutes) {
          amOutInput.classList.add('error');
          errors.push('AM Out must be after AM In');
          isValid = false;
        }
      }
    }

    if (pmInInput && pmOutInput) {
      if (pmInInput.value && !pmOutInput.value) {
        pmOutInput.classList.add('error');
        errors.push('PM Out is required when PM In is entered');
        isValid = false;
      } else if (!pmInInput.value && pmOutInput.value) {
        pmInInput.classList.add('error');
        errors.push('PM In is required when PM Out is entered');
        isValid = false;
      } else if (pmInInput.value && pmOutInput.value) {
        const pmInMinutes = timeToMinutes(pmInInput.value);
        const pmOutMinutes = timeToMinutes(pmOutInput.value);
        if (pmOutMinutes <= pmInMinutes) {
          pmOutInput.classList.add('error');
          errors.push('PM Out must be after PM In');
          isValid = false;
        }
      }
    }

    // Validate that PM In is not earlier than AM Out
    if (amOutInput && amOutInput.value && pmInInput && pmInInput.value) {
      const amOutMinutes = timeToMinutes(amOutInput.value);
      const pmInMinutes = timeToMinutes(pmInInput.value);
      if (pmInMinutes < amOutMinutes) {
        pmInInput.classList.add('error');
        errors.push('PM In cannot be earlier than AM Out');
        isValid = false;
      }
    }

    // Check if date is filled but ALL time inputs are empty
    const dateInput = row.querySelector('.date-input');
    if (dateInput && dateInput.value) {
      const selectedDate = new Date(dateInput.value);
      const dateStr = selectedDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

      // Validate that date is not in the future
      const today = new Date();
      today.setHours(23, 59, 59, 999); // Set to end of today for comparison

      if (selectedDate > today) {
        dateInput.classList.add('error');
        errors.push(`Date ${dateStr} is in the future. Cannot log overtime for future dates.`);
        isValid = false;
      } else {
        dateInput.classList.remove('error');
      }

      // Validate that date matches selected month and year
      const monthSelect = document.getElementById('month');
      const yearSelect = document.getElementById('year');
      if (monthSelect && yearSelect && monthSelect.value && yearSelect.value) {
        const selectedMonth = selectedDate.getMonth(); // 0-11
        const selectedYear = selectedDate.getFullYear();

        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
        const formMonth = monthNames.indexOf(monthSelect.value);
        const formYear = parseInt(yearSelect.value);

        if (selectedMonth !== formMonth || selectedYear !== formYear) {
          dateInput.classList.add('error');
          errors.push(`Date ${dateStr} does not match selected month/year (${monthSelect.value} ${yearSelect.value})`);
          isValid = false;
        }
      }

      const hasAnyTime = (amInInput && amInInput.value) ||
                         (amOutInput && amOutInput.value) ||
                         (pmInInput && pmInInput.value) ||
                         (pmOutInput && pmOutInput.value);

      if (!hasAnyTime) {
        // Mark all time inputs as error to show user they need at least one
        if (amInInput) amInInput.classList.add('error');
        if (amOutInput) amOutInput.classList.add('error');
        if (pmInInput) pmInInput.classList.add('error');
        if (pmOutInput) pmOutInput.classList.add('error');
        errors.push(`Row with date ${dateStr}: At least one time entry (AM or PM) is required`);
        isValid = false;
      } else {
        // If at least one time is entered, remove the "required" error from empty fields
        // (but keep errors from other validation rules like range/pair validation)
        // This is handled by the individual validateTimeInput calls above
      }
    }

    return { isValid, errors };
  }

  /**
   * Update grand total
   */
  function updateGrandTotal() {
    const rows = document.querySelectorAll('#entryTableBody tr');
    let grandTotal = 0;

    rows.forEach(row => {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        const cocEarnedDiv = document.getElementById('cocEarned-' + rowId);
        if (cocEarnedDiv) {
          const value = parseFloat(cocEarnedDiv.textContent) || 0;
          grandTotal += value;
        }
      }
    });

    const grandTotalDiv = document.getElementById('grandTotal');
    if (grandTotalDiv) {
      grandTotalDiv.textContent = grandTotal.toFixed(1) + ' hours';
    }
  }

  /**
   * Handle overtime form submission
   */
  function handleOvertimeFormSubmit(e) {
    e.preventDefault();

    const employeeId = parseInt(document.getElementById('employeeId')?.value);
    const month = document.getElementById('month')?.value;
    const year = parseInt(document.getElementById('year')?.value);

    if (!employeeId || !month || !year) {
      showAlert('Please select Employee, Month, and Year', 'error');
      return false;
    }

    const rows = document.querySelectorAll('#entryTableBody tr');
    let allRowsValid = true;
    const allErrors = [];

    rows.forEach(row => {
      const rowIdMatch = row.id.match(/row-(\d+)/);
      if (rowIdMatch) {
        const rowId = parseInt(rowIdMatch[1]);
        const validation = validateOvertimeRow(rowId);
        if (!validation.isValid) {
          allRowsValid = false;
          allErrors.push(...validation.errors);
        }
      }
    });

    if (!allRowsValid) {
      const errorMessage = 'Please correct the following errors:\n\n' + allErrors.map((err, i) => `${i + 1}. ${err}`).join('\n');
      showAlert(errorMessage, 'error');
      return false;
    }

    const entries = [];
    rows.forEach(row => {
      const dateInput = row.querySelector('.date-input');
      const amIn = row.querySelector('.am-in')?.value;
      const amOut = row.querySelector('.am-out')?.value;
      const pmIn = row.querySelector('.pm-in')?.value;
      const pmOut = row.querySelector('.pm-out')?.value;

      if (dateInput && dateInput.value) {
        // Check if at least one time input is filled
        const hasAnyTime = amIn || amOut || pmIn || pmOut;
        if (!hasAnyTime) {
          // Skip entries with date but no time inputs
          return;
        }

        entries.push({
          dateWorked: dateInput.value,
          amIn: formatTimeFor12Hour(amIn),
          amOut: formatTimeFor12Hour(amOut),
          pmIn: formatTimeFor12Hour(pmIn),
          pmOut: formatTimeFor12Hour(pmOut)
        });
      }
    });

    if (entries.length === 0) {
      showAlert('Please add at least one overtime entry with date and time', 'error');
      return false;
    }

    const batchData = { employeeId, month, year, entries };
    const saveBtn = document.getElementById('saveBtn');
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }

    google.script.run
      .withSuccessHandler(result => {
        if (result.success) {
          showAlert(result.message, 'success');
          setTimeout(() => resetOvertimeForm(), 2000);
        } else {
          showAlert(result.message, 'error');
        }
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Overtime Batch';
        }
      })
      .withFailureHandler(err => {
        showAlert('Error: ' + err.message, 'error');
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Overtime Batch';
        }
      })
      .saveOvertimeBatch(batchData);

    return false;
  }

  /**
   * Format time for 12-hour display
   */
  function formatTimeFor12Hour(time24) {
    if (!time24 || time24.trim() === '') return '';
    try {
      const [hours, minutes] = time24.split(':');
      let h = parseInt(hours, 10);
      const m = minutes;
      const period = h >= 12 ? 'PM' : 'AM';
      if (h === 0) h = 12;
      else if (h > 12) h -= 12;
      return `${h.toString().padStart(2, '0')}:${m} ${period}`;
    } catch (error) {
      return '';
    }
  }

  /**
   * Reset overtime form
   */
  function resetOvertimeForm() {
    const form = document.getElementById('overtimeForm');
    if (form) form.reset();

    const tbody = document.getElementById('entryTableBody');
    if (tbody) tbody.innerHTML = '';

    rowCounter = 0;
    existingDatabaseDates = [];
    duplicateContext = null;

    // Reset button and overlay state
    checkAddDayButtonState();
    updateGrandTotal();
  }

  /**
   * Load stats for Log Overtime page (deprecated)
   */
  function loadLogOvertimeStats() {
    // Deprecated - stats removed from embedded form
  }

  // ========== UNCERTIFIED REPORT PAGE ==========

  let allUncertifiedLogs = [];

  /**
   * Load uncertified report
   */
  function loadUncertifiedReport() {
    // Load stats
    loadUncertifiedReportStats();

    // Load filter dropdowns
    loadUncertifiedReportFilters();

    // Load report data
    google.script.run
      .withSuccessHandler(logs => {
        allUncertifiedLogs = logs;
        renderUncertifiedReport(logs);
      })
      .withFailureHandler(err => {
        document.getElementById('uncertifiedReportContainer').innerHTML = `
          <div style="text-align: center; padding: 3rem; color: #ef4444;">
            <i class="fas fa-exclamation-circle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
            <p>Error loading report: ${err.message}</p>
          </div>`;
      })
      .getAllUncertifiedLogs();
  }

  /**
   * Load stats for uncertified report
   */
  function loadUncertifiedReportStats() {
    google.script.run
      .withSuccessHandler(stats => {
        document.getElementById('totalUncertifiedHours').textContent = stats.totalHours.toFixed(1);
        document.getElementById('totalUncertifiedEntries').textContent = stats.totalEntries;
        document.getElementById('employeesWithUncertified').textContent = stats.employeeCount;
        document.getElementById('oldestUncertified').textContent = stats.oldestDate || '--';
      })
      .withFailureHandler(err => {
        console.error('Error loading stats:', err);
      })
      .getUncertifiedReportStats();
  }

  /**
   * Load filter dropdowns
   */
  function loadUncertifiedReportFilters() {
    // Load employees for filter
    google.script.run
      .withSuccessHandler(employees => {
        const select = document.getElementById('filterEmployee');
        if (!select) return;

        employees.forEach(emp => {
          const option = document.createElement('option');
          option.value = emp.id;
          option.textContent = emp.name;
          select.appendChild(option);
        });
      })
      .getEmployeesForDropdown();

    // Populate years (2024 to current year)
    const yearSelect = document.getElementById('filterYear');
    if (yearSelect) {
      const currentYear = new Date().getFullYear();
      for (let year = currentYear; year >= 2024; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
      }
    }
  }

  /**
   * Render uncertified report table
   */
  function renderUncertifiedReport(logs) {
    const container = document.getElementById('uncertifiedReportContainer');
    if (!container) return;

    if (logs.length === 0) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-check-circle"></i>
          <p>No uncertified logs found</p>
        </div>`;
      return;
    }

    // Group by employee
    const grouped = {};
    logs.forEach(log => {
      const key = log.employeeId;
      if (!grouped[key]) {
        grouped[key] = {
          employeeName: log.employeeName,
          logs: [],
          totalHours: 0
        };
      }
      grouped[key].logs.push(log);
      grouped[key].totalHours += log.cocEarned;
    });

    let html = '<div style="padding: 1.5rem;">';

    Object.keys(grouped).forEach(employeeId => {
      const group = grouped[employeeId];

      html += `
        <div style="margin-bottom: 2rem; border: 1px solid #e8ebed; border-radius: 8px; overflow: hidden;">
          <div style="background: #f8f9fa; padding: 1rem 1.5rem; border-bottom: 1px solid #e8ebed;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <div style="font-weight: 600; color: #1a1f36; font-size: 1rem;">${group.employeeName}</div>
                <div style="font-size: 0.875rem; color: #697386;">Employee ID: ${employeeId}</div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 0.875rem; color: #697386;">Total Uncertified</div>
                <div style="font-size: 1.25rem; font-weight: 700; color: #4f46e5;">${group.totalHours.toFixed(1)} hrs</div>
              </div>
            </div>
          </div>
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead style="background: #fafbfc;">
                <tr>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Date Worked</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Month/Year</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">Day Type</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">AM In</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">AM Out</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">PM In</th>
                  <th style="padding: 0.75rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">PM Out</th>
                  <th style="padding: 0.75rem; text-align: center; font-size: 0.75rem; font-weight: 600; color: #697386; text-transform: uppercase;">COC Earned</th>
                </tr>
              </thead>
              <tbody>`;

      group.logs.forEach(log => {
        const dayTypeColor = log.dayType === 'Weekday' ? '#3b82f6' : (log.dayType === 'Holiday' ? '#ef4444' : '#10b981');
        html += `
          <tr style="border-bottom: 1px solid #f0f2f5;">
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.dateWorked}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.month} ${log.year}</td>
            <td style="padding: 0.75rem;">
              <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; background: ${dayTypeColor}15; color: ${dayTypeColor};">
                ${log.dayType}
              </span>
            </td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.amIn || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.amOut || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.pmIn || '--'}</td>
            <td style="padding: 0.75rem; font-size: 0.875rem;">${log.pmOut || '--'}</td>
            <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: #4f46e5; font-size: 0.875rem;">${log.cocEarned.toFixed(1)}</td>
          </tr>`;
      });

      html += `
              </tbody>
            </table>
          </div>
        </div>`;
    });

    html += '</div>';
    container.innerHTML = html;
  }

  /**
   * Filter uncertified report
   */
  function filterUncertifiedReport() {
    const employeeFilter = document.getElementById('filterEmployee').value;
    const monthFilter = document.getElementById('filterMonth').value;
    const yearFilter = document.getElementById('filterYear').value;

    let filtered = allUncertifiedLogs;

    if (employeeFilter) {
      filtered = filtered.filter(log => log.employeeId == employeeFilter);
    }

    if (monthFilter) {
      filtered = filtered.filter(log => log.month === monthFilter);
    }

    if (yearFilter) {
      filtered = filtered.filter(log => log.year == yearFilter);
    }

    renderUncertifiedReport(filtered);
  }

  /**
   * Clear filters
   */
  function clearFilters() {
    document.getElementById('filterEmployee').value = '';
    document.getElementById('filterMonth').value = '';
    document.getElementById('filterYear').value = '';
    renderUncertifiedReport(allUncertifiedLogs);
  }

  /**
   * Export to CSV
   */
  function exportToCSV() {
    if (allUncertifiedLogs.length === 0) {
      showAlert('No data to export', 'error');
      return;
    }

    let csv = 'Employee Name,Employee ID,Date Worked,Month,Year,Day Type,AM In,AM Out,PM In,PM Out,COC Earned\n';

    allUncertifiedLogs.forEach(log => {
      csv += `"${log.employeeName}",${log.employeeId},"${log.dateWorked}","${log.month}",${log.year},"${log.dayType}","${log.amIn || ''}","${log.amOut || ''}","${log.pmIn || ''}","${log.pmOut || ''}",${log.cocEarned}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `uncertified-report-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);

    showAlert('Report exported successfully', 'success');
  }

  // ========== GENERATE CERTIFICATE PAGE ==========

  let allCertEmployees = [];
  let selectedCertEmployee = null;

  /**
   * Initialize Generate Certificate page when loaded
   */
  function initGenerateCertificateForm() {
    console.log('initGenerateCertificateForm called');

    const container = document.getElementById('certEmployeeListContainer');
    if (container) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-spinner fa-spin"></i>
          <p>Loading employees...</p>
        </div>`;
    }

    // Load employees into list
    google.script.run
      .withSuccessHandler(employees => {
        console.log('Employees loaded:', employees.length);
        allCertEmployees = employees;
        renderCertEmployeeList(employees);
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        if (container) {
          container.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading employees</p></div>';
        }
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();
  }

  /**
   * Render employee list for certificate generation
   */
  function renderCertEmployeeList(employees) {
    const container = document.getElementById('certEmployeeListContainer');
    if (!container) {
      console.error('renderCertEmployeeList: Container not found');
      return;
    }

    container.innerHTML = '';

    if (employees.length === 0) {
      container.innerHTML = '<div class="empty-state"><i class="fas fa-search"></i><p>No employees found</p></div>';
      return;
    }

    // Create employee cards
    employees.forEach(emp => {
      const div = document.createElement('div');
      div.className = 'employee-list-item';

      // Check if this employee is the currently selected one
      if (selectedCertEmployee && emp.id === selectedCertEmployee.id) {
        div.classList.add('active');
      }

      div.onclick = (event) => selectCertEmployee(emp, event.currentTarget);

      div.innerHTML = `
        <div class="employee-name">${emp.name}</div>
        <div class="employee-meta">Employee ID: ${emp.id}</div>
      `;

      container.appendChild(div);
    });
  }

  /**
   * Filter certificate employee list based on search input
   */
  function filterCertEmployees() {
    const searchInput = document.getElementById('certEmployeeSearch');
    if (!searchInput) return;

    const searchTerm = searchInput.value.toLowerCase();
    const filtered = allCertEmployees.filter(emp => {
      const searchString = `${emp.name} ${emp.id}`.toLowerCase();
      return searchString.includes(searchTerm);
    });

    renderCertEmployeeList(filtered);
  }

  /**
   * Select an employee and load their uncertified logs grouped by month
   */
  function selectCertEmployee(employee, clickedElement) {
    console.log('Selecting employee:', employee);

    selectedCertEmployee = employee;

    // Highlight active employee in list
    document.querySelectorAll('#certEmployeeListContainer .employee-list-item').forEach(item => {
      item.classList.remove('active');
    });
    if (clickedElement) {
      clickedElement.classList.add('active');
    }

    const certContent = document.getElementById('certContent');
    const certEmptyState = document.getElementById('certEmptyState');
    const uncertifiedMonthsContainer = document.getElementById('uncertifiedMonthsContainer');

    // Show loading state
    if (certContent) certContent.style.display = 'block';
    if (certEmptyState) certEmptyState.style.display = 'none';
    if (uncertifiedMonthsContainer) {
      uncertifiedMonthsContainer.innerHTML = '<div class="empty-state"><i class="fas fa-spinner fa-spin"></i><p>Loading uncertified overtime...</p></div>';
    }

    // Update employee info
    const employeeNameDisplay = document.getElementById('certEmployeeNameDisplay');
    const employeeIdDisplay = document.getElementById('certEmployeeIdDisplay');

    if (employeeNameDisplay) {
      employeeNameDisplay.textContent = employee.name;
    }
    if (employeeIdDisplay) {
      employeeIdDisplay.textContent = `Employee ID: ${employee.id}`;
    }

    // Fetch uncertified logs grouped by month
    google.script.run
      .withSuccessHandler(monthGroups => {
        console.log('Uncertified month groups received:', monthGroups);
        renderUncertifiedMonths(monthGroups);
      })
      .withFailureHandler(err => {
        console.error('Error loading uncertified logs:', err);
        showAlert('Error loading uncertified logs: ' + err.message, 'error');
        if (uncertifiedMonthsContainer) {
          uncertifiedMonthsContainer.innerHTML = `
            <div class="empty-state">
              <i class="fas fa-exclamation-triangle"></i>
              <p>Error loading uncertified overtime</p>
            </div>`;
        }
      })
      .getUncertifiedLogsByEmployee(parseInt(employee.id));
  }

  /**
   * Render uncertified months with certificate generation forms
   */
  function renderUncertifiedMonths(monthGroups) {
    const container = document.getElementById('uncertifiedMonthsContainer');
    if (!container) return;

    if (!monthGroups || monthGroups.length === 0) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-check-circle" style="color: #10b981;"></i>
          <p>No uncertified overtime found for this employee</p>
        </div>`;
      return;
    }

    container.innerHTML = '';

    // Get today's date in YYYY-MM-DD format for max attribute
    const today = new Date();
    const maxDate = today.toISOString().split('T')[0];

    // Render each month group
    monthGroups.forEach((group, index) => {
      const card = document.createElement('div');
      card.className = 'month-certificate-card';
      card.id = `cert-month-${index}`;

      const detailsId = `cert-details-${index}`;

      card.innerHTML = `
        <div class="month-header">
          <div>
            <div class="month-title">${group.month} ${group.year}</div>
            <div style="font-size: 0.875rem; color: #697386; margin-top: 0.25rem;">
              ${group.logs.length} overtime ${group.logs.length === 1 ? 'entry' : 'entries'}
            </div>
          </div>
          <div style="text-align: right;">
            <div style="font-size: 0.875rem; color: #697386; margin-bottom: 0.25rem;">Total Hours</div>
            <div class="month-hours">${group.totalHours.toFixed(1)} hrs</div>
          </div>
        </div>

        <!-- Overtime Logs Summary -->
        <div style="margin-bottom: 1.5rem;">
          <button onclick="toggleCertDetails('${detailsId}')" style="padding: 0.5rem 1rem; font-size: 0.875rem; background: #e0e7ff; color: #4f46e5; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
            <i class="fas fa-eye"></i> View ${group.logs.length} Overtime ${group.logs.length === 1 ? 'Entry' : 'Entries'}
          </button>

          <div id="${detailsId}" style="display: none; margin-top: 1rem; background: #f9fafb; border: 1px solid #e8ebed; border-radius: 6px; padding: 1rem;">
            <table style="width: 100%; font-size: 0.875rem; border-collapse: collapse;">
              <thead>
                <tr style="background: #f0f2f5;">
                  <th style="padding: 0.5rem; text-align: left;">Date</th>
                  <th style="padding: 0.5rem; text-align: left;">Day Type</th>
                  <th style="padding: 0.5rem; text-align: center;">AM In</th>
                  <th style="padding: 0.5rem; text-align: center;">AM Out</th>
                  <th style="padding: 0.5rem; text-align: center;">PM In</th>
                  <th style="padding: 0.5rem; text-align: center;">PM Out</th>
                  <th style="padding: 0.5rem; text-align: center;">COC</th>
                </tr>
              </thead>
              <tbody>
                ${group.logs.map(log => `
                  <tr style="border-bottom: 1px solid #e8ebed;">
                    <td style="padding: 0.5rem;">${log.dateWorked}</td>
                    <td style="padding: 0.5rem;">${log.dayType}</td>
                    <td style="padding: 0.5rem; text-align: center;">${log.amIn || '--'}</td>
                    <td style="padding: 0.5rem; text-align: center;">${log.amOut || '--'}</td>
                    <td style="padding: 0.5rem; text-align: center;">${log.pmIn || '--'}</td>
                    <td style="padding: 0.5rem; text-align: center;">${log.pmOut || '--'}</td>
                    <td style="padding: 0.5rem; text-align: center; font-weight: 600; color: #4f46e5;">${log.cocEarned.toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </div>

        <!-- Certificate Generation Form -->
        <form id="certForm-${index}" onsubmit="return handleMonthCertificateSubmit(event, ${index}, '${group.month}', ${group.year})">
          <div class="cert-form-group">
            <label class="cert-form-label">
              Date of Issuance <span style="color: #ef4444;">*</span>
            </label>
            <input type="date" id="certDate-${index}" required class="form-input"
                   style="max-width: 300px;" max="${maxDate}"
                   onchange="updateCertValidUntil(${index})">
            <p style="color: #697386; font-size: 0.75rem; margin-top: 0.5rem;">
              <i class="fas fa-info-circle"></i> Valid Until: <span id="certValidUntil-${index}">--</span>
            </p>
          </div>

          <div style="text-align: right;">
            <button type="submit" id="certBtn-${index}" class="btn btn-primary">
              <i class="fas fa-certificate"></i> Generate Certificate for ${group.month} ${group.year}
            </button>
          </div>
        </form>
      `;

      container.appendChild(card);
    });
  }

  /**
   * Toggle visibility of certificate details
   */
  function toggleCertDetails(detailsId) {
    const details = document.getElementById(detailsId);
    if (details) {
      if (details.style.display === 'none') {
        details.style.display = 'block';
      } else {
        details.style.display = 'none';
      }
    }
  }

  /**
   * Update Valid Until date for a specific certificate form
   */
  function updateCertValidUntil(index) {
    const dateInput = document.getElementById(`certDate-${index}`);
    const validUntilSpan = document.getElementById(`certValidUntil-${index}`);

    if (!dateInput || !dateInput.value || !validUntilSpan) return;

    // Calculate Valid Until: (Date of Issuance + 1 Year - 1 Day)
    const issuanceDate = new Date(dateInput.value);
    const validUntil = new Date(issuanceDate);
    validUntil.setFullYear(validUntil.getFullYear() + 1);
    validUntil.setDate(validUntil.getDate() - 1);

    // Format date as MM/DD/YYYY
    const formattedDate = (validUntil.getMonth() + 1).toString().padStart(2, '0') + '/' +
                          validUntil.getDate().toString().padStart(2, '0') + '/' +
                          validUntil.getFullYear();

    validUntilSpan.textContent = formattedDate;
  }

  /**
   * Handle certificate submission for a specific month
   */
  function handleMonthCertificateSubmit(event, index, month, year) {
    event.preventDefault();

    if (!selectedCertEmployee) {
      showAlert('No employee selected', 'error');
      return false;
    }

    const dateOfIssuance = document.getElementById(`certDate-${index}`)?.value;

    if (!dateOfIssuance) {
      showAlert('Please enter Date of Issuance', 'error');
      return false;
    }

    // Validate date is not in the future
    const selectedDate = new Date(dateOfIssuance);
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Reset time to start of day for comparison

    if (selectedDate > today) {
      showAlert('Date of Issuance cannot be in the future', 'error');
      return false;
    }

    const certBtn = document.getElementById(`certBtn-${index}`);
    const originalBtnContent = certBtn ? certBtn.innerHTML : '';

    if (certBtn) {
      certBtn.disabled = true;
      certBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
    }

    const certificateData = {
      employeeId: parseInt(selectedCertEmployee.id),
      month: month,
      year: year,
      dateOfIssuance: dateOfIssuance
    };

    google.script.run
      .withSuccessHandler(result => {
        if (result.success) {
          showAlert(result.message, 'success');

          // If PDF was generated, open it in a new tab
          if (result.pdfUrl) {
            setTimeout(() => {
              window.open(result.pdfUrl, '_blank');
            }, 500);
          }

          // Reload uncertified logs for this employee
          setTimeout(() => {
            selectCertEmployee(selectedCertEmployee, document.querySelector('#certEmployeeListContainer .employee-list-item.active'));
          }, 2000);
        } else {
          showAlert(result.message, 'error');
        }

        if (certBtn) {
          certBtn.disabled = false;
          certBtn.innerHTML = originalBtnContent;
        }
      })
      .withFailureHandler(err => {
        showAlert('Error generating certificate: ' + err.message, 'error');
        if (certBtn) {
          certBtn.disabled = false;
          certBtn.innerHTML = originalBtnContent;
        }
      })
      .generateCOCCertificate(certificateData);

    return false;
  }

  // ========== EMPLOYEE LEDGER PAGE ==========

  let allLedgerEmployees = [];
  let selectedLedgerEmployee = null;

  /**
   * Initialize Employee Ledger form when page loads
   */
  function initEmployeeLedgerForm() {
    console.log('initEmployeeLedgerForm called');

    const container = document.getElementById('ledgerEmployeeListContainer');
    if (container) {
      container.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-spinner fa-spin"></i>
          <p>Loading employees...</p>
        </div>`;
    }

    // Load employees into list
    google.script.run
      .withSuccessHandler(employees => {
        console.log('Employees loaded:', employees.length);
        allLedgerEmployees = employees;
        renderLedgerEmployeeList(employees);
      })
      .withFailureHandler(err => {
        console.error('Error loading employees:', err);
        if (container) {
          container.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading employees</p></div>';
        }
        showAlert('Error loading employees: ' + err.message, 'error');
      })
      .getEmployeesForDropdown();
  }

  /**
   * Render employee list for ledger
   */
  function renderLedgerEmployeeList(employees) {
    const container = document.getElementById('ledgerEmployeeListContainer');
    if (!container) {
      console.error('renderLedgerEmployeeList: Container not found');
      return;
    }

    container.innerHTML = '';

    if (employees.length === 0) {
      container.innerHTML = '<div class="empty-state"><i class="fas fa-search"></i><p>No employees found</p></div>';
      return;
    }

    // Create employee cards
    employees.forEach(emp => {
      const div = document.createElement('div');
      div.className = 'employee-list-item';

      // Check if this employee is the currently selected one
      if (selectedLedgerEmployee && emp.id === selectedLedgerEmployee.id) {
        div.classList.add('active');
      }

      div.onclick = (event) => selectLedgerEmployee(emp, event.currentTarget);

      div.innerHTML = `
        <div class="employee-name">${emp.name}</div>
        <div class="employee-meta">Employee ID: ${emp.id}</div>
      `;

      container.appendChild(div);
    });
  }

  /**
   * Filter ledger employee list based on search input
   */
  function filterLedgerEmployees() {
    const searchInput = document.getElementById('ledgerEmployeeSearch');
    if (!searchInput) return;

    const searchTerm = searchInput.value.toLowerCase();
    const filtered = allLedgerEmployees.filter(emp => {
      const searchString = `${emp.name} ${emp.id}`.toLowerCase();
      return searchString.includes(searchTerm);
    });

    renderLedgerEmployeeList(filtered);
  }

  /**
   * Select an employee and load their ledger
   */
  function selectLedgerEmployee(employee, clickedElement) {
    console.log('Selecting employee:', employee);

    selectedLedgerEmployee = employee;

    // Highlight active employee in list
    document.querySelectorAll('#ledgerEmployeeListContainer .employee-list-item').forEach(item => {
      item.classList.remove('active');
    });
    if (clickedElement) {
      clickedElement.classList.add('active');
    }

    const ledgerContent = document.getElementById('ledgerContent');
    const ledgerEmptyState = document.getElementById('ledgerEmptyState');
    const ledgerTableContainer = document.getElementById('ledgerTableContainer');

    // Show loading state
    if (ledgerContent) ledgerContent.style.display = 'block';
    if (ledgerEmptyState) ledgerEmptyState.style.display = 'none';
    if (ledgerTableContainer) {
      ledgerTableContainer.innerHTML = '<div class="empty-state"><i class="fas fa-spinner fa-spin"></i><p>Loading ledger...</p></div>';
    }

    // Fetch ledger data
    google.script.run
      .withSuccessHandler(ledgerData => {
        console.log('Ledger data received:', ledgerData);
        if (!ledgerData) {
          console.error('ledgerData is null or undefined');
        }
        renderEmployeeLedgerData(ledgerData, employee);
      })
      .withFailureHandler(err => {
        console.error('Error loading ledger:', err);
        showAlert('Error loading ledger: ' + err.message, 'error');
        if (ledgerTableContainer) {
          ledgerTableContainer.innerHTML = `
            <div class="empty-state">
              <i class="fas fa-exclamation-triangle"></i>
              <p>Error loading ledger</p>
            </div>`;
        }
      })
      .getEmployeeLedgerDetailed(parseInt(employee.id));
  }

  /**
   * Render ledger data to the page
   */
  function renderEmployeeLedgerData(ledgerData, employee) {
    // Null check
    if (!ledgerData) {
      console.error('renderEmployeeLedgerData: ledgerData is null or undefined');
      console.error('Employee object:', employee);
      showAlert('Error: Failed to load ledger data', 'error');

      // Hide loading and show error
      const ledgerContent = document.getElementById('ledgerContent');
      const ledgerEmptyState = document.getElementById('ledgerEmptyState');
      if (ledgerContent) ledgerContent.style.display = 'none';
      if (ledgerEmptyState) {
        ledgerEmptyState.style.display = 'block';
        ledgerEmptyState.innerHTML = `
          <div style="text-align: center; padding: 3rem;">
            <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #ef4444; margin-bottom: 1rem;"></i>
            <p style="color: #697386;">Failed to load ledger data. Please try again.</p>
          </div>
        `;
      }
      return;
    }

    // Display employee info
    const employeeNameDisplay = document.getElementById('employeeNameDisplay');
    const employeeIdDisplay = document.getElementById('employeeIdDisplay');

    if (employee && employeeNameDisplay && employeeIdDisplay) {
      // Use employee.name if available, otherwise construct from parts
      const fullName = employee.name || `${employee.firstName || ''} ${employee.middleInitial ? employee.middleInitial + '.' : ''} ${employee.lastName || ''}`.trim();
      employeeNameDisplay.textContent = fullName;
      // Use employee.id (from getEmployeesForDropdown) or employeeId (if available)
      const empId = employee.id || employee.employeeId;
      employeeIdDisplay.textContent = `Employee ID: ${empId}`;
    }

    // Update balance displays (compact format - no "hrs" suffix)
    const activeBalanceDisplay = document.getElementById('activeBalanceDisplay');
    const uncertifiedBalanceDisplay = document.getElementById('uncertifiedBalanceDisplay');
    const totalEarnedDisplay = document.getElementById('totalEarnedDisplay');
    const usedCOCsDisplay = document.getElementById('usedCOCsDisplay');

    if (activeBalanceDisplay) activeBalanceDisplay.textContent = (ledgerData.activeBalance || 0).toFixed(1);
    if (uncertifiedBalanceDisplay) uncertifiedBalanceDisplay.textContent = (ledgerData.uncertifiedBalance || 0).toFixed(1);
    if (totalEarnedDisplay) totalEarnedDisplay.textContent = (ledgerData.totalEarned || 0).toFixed(1);
    if (usedCOCsDisplay) usedCOCsDisplay.textContent = (ledgerData.usedCOCs || 0).toFixed(1);

    // Separate historical data from current transactions
    const transactions = ledgerData.transactions || [];
    const historicalData = transactions.filter(tx => tx.isHistorical);
    const currentTransactions = transactions.filter(tx => !tx.isHistorical);

    // ========================================
    // PART 1: Render Beginning Balance (Historical Data)
    // ========================================
    const beginningBalanceSection = document.getElementById('beginningBalanceSection');
    const beginningBalanceContainer = document.getElementById('beginningBalanceContainer');

    if (historicalData.length > 0) {
      if (beginningBalanceSection) beginningBalanceSection.style.display = 'block';

      if (beginningBalanceContainer) {
        let historicalRows = '';
        let totalHistoricalEarned = 0;
        let totalHistoricalUsed = 0;
        let totalHistoricalRemaining = 0;

        historicalData.forEach(tx => {
          const statusColors = {
            'Active': '#10b981',
            'Used': '#6b7280',
            'Expired': '#ef4444'
          };
          const statusColor = statusColors[tx.status] || '#6b7280';

          const dateOfIssuanceDisplay = tx.dateOfIssuance || '--';
          const validUntilDisplay = tx.validUntil
            ? new Date(tx.validUntil).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
            : '--';

          const earned = tx.cocEarned || 0;
          const used = tx.cocUsed || 0;
          const remaining = tx.cocRemaining || 0;

          totalHistoricalEarned += earned;
          totalHistoricalUsed += used;
          totalHistoricalRemaining += remaining;

          console.log('Historical transaction:', {
            month: tx.month,
            year: tx.year,
            earned: earned,
            used: used,
            remaining: remaining,
            dateOfIssuance: dateOfIssuanceDisplay,
            validUntil: validUntilDisplay,
            status: tx.status
          });

          // Note: Removed inline styles, will be controlled by <style> tag in EmployeeLedger
          historicalRows += `
            <tr>
              <td>${tx.month} ${tx.year}</td>
              <td class="text-center font-semibold" style="color: #10b981;">${earned.toFixed(1)}</td>
              <td class="text-center font-semibold" style="color: #ef4444;">${used.toFixed(1)}</td>
              <td class="text-center font-semibold" style="color: #4f46e5;">${remaining.toFixed(1)}</td>
              <td class="text-center">${dateOfIssuanceDisplay}</td>
              <td class="text-center">${validUntilDisplay}</td>
              <td class="text-center">
                <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-weight: 600; background: ${statusColor}15; color: ${statusColor}; font-size: 0.8125rem;">
                  ${tx.status}
                </span>
              </td>
            </tr>
          `;
        });

        beginningBalanceContainer.innerHTML = `
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse;">
              <thead>
                <tr>
                  <th>Month/Year</th>
                  <th class="text-center">Earned</th>
                  <th class="text-center">Used</th>
                  <th class="text-center">Remaining</th>
                  <th class="text-center">Date of Issuance</th>
                  <th class="text-center">Valid Until</th>
                  <th class="text-center">Status</th>
                </tr>
              </thead>
              <tbody>
                ${historicalRows}
              </tbody>
            </table>
          </div>
          <div style="margin-top: 0.75rem; padding: 1rem; background: white; border-radius: 6px; border: 1px solid #e1e4e8; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
            <div>
              <span style="font-size: 0.8125rem; color: #697386; display: block; text-transform: uppercase; margin-bottom: 0.25rem;">Total Earned</span>
              <span style="font-weight: 700; color: #10b981; font-size: 1.25rem;">${totalHistoricalEarned.toFixed(1)} hrs</span>
            </div>
            <div>
              <span style="font-size: 0.8125rem; color: #697386; display: block; text-transform: uppercase; margin-bottom: 0.25rem;">Total Used</span>
              <span style="font-weight: 700; color: #ef4444; font-size: 1.25rem;">${totalHistoricalUsed.toFixed(1)} hrs</span>
            </div>
            <div>
              <span style="font-size: 0.8125rem; color: #697386; display: block; text-transform: uppercase; margin-bottom: 0.25rem;">Total Remaining</span>
              <span style="font-weight: 700; color: #4f46e5; font-size: 1.25rem;">${totalHistoricalRemaining.toFixed(1)} hrs</span>
            </div>
          </div>
        `;
      }
    } else {
      if (beginningBalanceSection) beginningBalanceSection.style.display = 'none';
    }

    // ========================================
    // PART 2: Render COC Ledger (Certificates)
    // ========================================
    const ledgerTableContainer = document.getElementById('ledgerTableContainer');
    if (!ledgerTableContainer) return;

    // Group current transactions by certificate (Month/Year)
    const certificates = {};
    const ctoUsage = [];

    currentTransactions.forEach(tx => {
      if (tx.status === 'Uncertified' || tx.status === 'Active' || tx.status === 'Expired') {
        // This is part of a certificate
        const key = `${tx.month}-${tx.year}`;
        if (!certificates[key]) {
          certificates[key] = {
            month: tx.month,
            year: tx.year,
            cocEarned: 0,
            cocUsed: 0,
            cocRemaining: 0,
            dateOfIssuance: tx.dateOfIssuance,
            validUntil: tx.validUntil,
            status: tx.status,
            entries: []
          };
        }
        certificates[key].cocEarned += tx.cocEarned;
        certificates[key].entries.push(tx);
      } else if (tx.status === 'Used') {
        // This is CTO usage
        ctoUsage.push(tx);
      }
    });

    if (Object.keys(certificates).length === 0 && ctoUsage.length === 0) {
      ledgerTableContainer.innerHTML = `
        <div class="empty-state">
          <i class="fas fa-info-circle"></i>
          <p>No new transactions found</p>
        </div>`;
      return;
    }

    // Build ledger table with certificates and CTO usage
    let ledgerRows = '';
    const statusColors = {
      'Active': '#10b981',
      'Uncertified': '#f59e0b',
      'Used': '#6b7280',
      'Expired': '#ef4444'
    };

    // Render certificates
    Object.keys(certificates).sort().forEach((key, index) => {
      const cert = certificates[key];
      const statusColor = statusColors[cert.status] || '#6b7280';
      const dateOfIssuanceDisplay = cert.dateOfIssuance || '--';
      const validUntilDisplay = cert.validUntil
        ? new Date(cert.validUntil).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
        : '--';

      const detailsId = `cert-details-${index}`;

      // Calculate total used and remaining for this certificate
      cert.cocUsed = cert.entries.reduce((sum, entry) => sum + (entry.cocUsed || 0), 0);
      cert.cocRemaining = cert.entries.reduce((sum, entry) => sum + (entry.cocRemaining || 0), 0);

      // Certificate summary row with View Details button
      ledgerRows += `
        <tr style="border-bottom: 1px solid #e1e4e8;">
          <td>
            <div style="font-weight: 600; color: #1a1f36;">Certificate - ${cert.month} ${cert.year}</div>
            <button onclick="toggleDetails('${detailsId}')" style="margin-top: 0.25rem; padding: 0.125rem 0.5rem; font-size: 0.65rem; background: #e0e7ff; color: #4f46e5; border: none; border-radius: 4px; cursor: pointer;">
              <i class="fas fa-eye"></i> View Details
            </button>
          </td>
          <td style="text-align: center; font-weight: 600; color: #10b981;">${cert.cocEarned.toFixed(1)}</td>
          <td style="text-align: center; font-weight: 600; color: #ef4444;">${cert.cocUsed.toFixed(1)}</td>
          <td style="text-align: center; font-weight: 600; color: #4f46e5;">${cert.cocRemaining.toFixed(1)}</td>
          <td style="text-align: center; font-size: 0.7rem;">${dateOfIssuanceDisplay}</td>
          <td style="text-align: center; font-size: 0.7rem;">${validUntilDisplay}</td>
          <td style="text-align: center;">
            <span style="display: inline-block; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.65rem; font-weight: 600; background: ${statusColor}15; color: ${statusColor};">
              ${cert.status}
            </span>
          </td>
        </tr>
        <tr id="${detailsId}" style="display: none; background: #f9fafb;">
          <td colspan="7" style="padding: 0.75rem;">
            <div style="font-size: 0.7rem; font-weight: 600; color: #697386; margin-bottom: 0.5rem;">OVERTIME ENTRIES:</div>
            <table style="width: 100%; font-size: 0.65rem;">
              <thead>
                <tr style="background: #f0f2f5;">
                  <th style="padding: 0.25rem; text-align: left;">Date</th>
                  <th style="padding: 0.25rem; text-align: left;">Day Type</th>
                  <th style="padding: 0.25rem; text-align: center;">AM In</th>
                  <th style="padding: 0.25rem; text-align: center;">AM Out</th>
                  <th style="padding: 0.25rem; text-align: center;">PM In</th>
                  <th style="padding: 0.25rem; text-align: center;">PM Out</th>
                  <th style="padding: 0.25rem; text-align: center;">COC Earned</th>
                </tr>
              </thead>
              <tbody>
                ${cert.entries.map(entry => `
                  <tr style="border-bottom: 1px solid #e1e4e8;">
                    <td style="padding: 0.25rem;">${entry.dateWorked}</td>
                    <td style="padding: 0.25rem;">${entry.dayType}</td>
                    <td style="padding: 0.25rem; text-align: center;">${entry.amIn || '--'}</td>
                    <td style="padding: 0.25rem; text-align: center;">${entry.amOut || '--'}</td>
                    <td style="padding: 0.25rem; text-align: center;">${entry.pmIn || '--'}</td>
                    <td style="padding: 0.25rem; text-align: center;">${entry.pmOut || '--'}</td>
                    <td style="padding: 0.25rem; text-align: center; font-weight: 600; color: #10b981;">${entry.cocEarned.toFixed(1)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </td>
        </tr>
      `;
    });

    const ledgerTable = `
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; background: white; border: 1px solid #e1e4e8; border-radius: 8px;">
          <thead>
            <tr>
              <th>Certificate</th>
              <th class="text-center">COC Earned</th>
              <th class="text-center">Used COCs</th>
              <th class="text-center">Remaining COCs</th>
              <th class="text-center">Date of Issuance</th>
              <th class="text-center">Valid Until</th>
              <th class="text-center">Status</th>
            </tr>
          </thead>
          <tbody>
            ${ledgerRows}
          </tbody>
        </table>
      </div>
    `;

    ledgerTableContainer.innerHTML = ledgerTable;
  }

  /**
   * Toggle visibility of certificate details
   */
  function toggleDetails(detailsId) {
    const detailsRow = document.getElementById(detailsId);
    if (detailsRow) {
      if (detailsRow.style.display === 'none') {
        detailsRow.style.display = 'table-row';
      } else {
        detailsRow.style.display = 'none';
      }
    }
  }

  // ========== AUTO-LOAD ON PAGE CHANGE ==========

  // Note: Both initLogOvertimeForm() and loadUncertifiedReport() are now called
  // from their respective view loaders in Main after HTML is fully loaded
</script>

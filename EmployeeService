// EmployeeService.gs - Employee CRUD operations

/**
 * Get all employees
 * UPDATED: Now uses Firestore objects instead of array-based rows
 * CACHE FIX: Renamed to _V2 and calls getSheetData_V2.
 */
function getAllEmployees_V2() {
  const data = getSheetData_V2('Employees'); // Use V2

  // Data is already in object format from Firestore
  // No need to map - just return as-is
  return serializeDates(data);
}

/**
 * Get employee by ID
 * UPDATED: Now uses Firestore objects instead of array-based rows
 * CACHE FIX: Renamed to _V2.
 */
function getEmployeeById_V2(employeeId) {
  // Ensure ID is a string for Firestore document path
  const employee = getRowById('Employees', String(employeeId), 0);
  if (!employee) return null;

  // Data is already in object format from Firestore
  return serializeDates(employee);
}

/**
 * Search employee by ID or Name
 * @param {string} searchValue - Employee ID (number) or name (string)
 * @returns {Object|null} Employee object or null if not found
 * CACHE FIX: Updated to call getEmployeeById_V2 and getSheetData_V2.
 */
function searchEmployeeByIdOrName(searchValue) {
  try {
    if (!searchValue) return null;

    const searchStr = searchValue.toString().trim().toLowerCase();

    // Try to search by ID first
    const employee = getEmployeeById_V2(searchStr); // Use V2
    if (employee) return employee;
    
    // If not found by ID, search by name
    const data = getSheetData_V2('Employees'); // Use V2

    for (let i = 0; i < data.length; i++) {
      const employee = data[i];
      const lastName = (employee.lastName || '').toString().toLowerCase();
      const firstName = (employee.firstName || '').toString().toLowerCase();
      const fullName = `${firstName} ${lastName}`.trim();
      const reverseName = `${lastName} ${firstName}`.trim();

      // Check if search matches firstName, lastName, or full name
      if (lastName.includes(searchStr) ||
          firstName.includes(searchStr) ||
          fullName.includes(searchStr) ||
          reverseName.includes(searchStr)) {

        return serializeDates(employee);
      }
    }

    // Not found
    return null;

  } catch (error) {
    Logger.log('Error in searchEmployeeByIdOrName: ' + error.toString());
    return null;
  }
}

/**
 * Create new employee
 * UPDATED: Now uses Firestore objects instead of arrays
 */
function createEmployee(employeeData) {
  try {
    const employeeId = getNextId('Employees', 'A');
    const currentEmail = getCurrentUserEmail();
    const currentDate = new Date();

    const employeeObject = {
      employeeId: String(employeeId),
      lastName: employeeData.lastName || '',
      firstName: employeeData.firstName || '',
      middleInitial: employeeData.middleInitial || '',
      suffix: employeeData.suffix || '',
      status: employeeData.status || 'Active',
      position: employeeData.position || '',
      office: employeeData.office || '',
      email: employeeData.email || ''
    };

    appendToSheet('Employees', employeeObject);

    return {
      success: true,
      employeeId: employeeId,
      message: 'Employee created successfully'
    };
  } catch (error) {
    return {
      success: false,
      message: 'Error creating employee: ' + error.message
    };
  }
}

/**
 * Update employee
 * UPDATED: Now uses Firestore objects instead of arrays
 * CACHE FIX: Updated to call getEmployeeById_V2.
 */
function updateEmployee(employeeId, employeeData) {
  try {
    // Ensure ID is a string
    const idStr = String(employeeId);
    
    const existing = getEmployeeById_V2(idStr); // Use V2
    if (!existing) {
      return {
        success: false,
        message: 'Employee not found'
      };
    }

    const updatedEmployee = {
      employeeId: idStr,
      lastName: employeeData.lastName || existing.lastName,
      firstName: employeeData.firstName || existing.firstName,
      middleInitial: employeeData.middleInitial || existing.middleInitial,
      suffix: employeeData.suffix || existing.suffix,
      status: employeeData.status || existing.status,
      position: employeeData.position || existing.position,
      office: employeeData.office || existing.office,
      email: employeeData.email || existing.email
    };

    updateRowById('Employees', idStr, updatedEmployee, 0);

    return {
      success: true,
      message: 'Employee updated successfully'
    };
  } catch (error) {
    return {
      success: false,
      message: 'Error updating employee: ' + error.message
    };
  }
}

/**
 * Delete employee (soft delete - set status to Inactive)
 * CACHE FIX: Updated to call getEmployeeById_V2.
 */
function deleteEmployee(employeeId) {
  try {
    const existing = getEmployeeById_V2(employeeId); // Use V2
    if (!existing) {
      return {
        success: false,
        message: 'Employee not found'
      };
    }
    
    // Soft delete - set status to Inactive
    return updateEmployee(employeeId, { status: 'Inactive' });
  } catch (error) {
    return {
      success: false,
      message: 'Error deleting employee: ' + error.message
    };
  }
}

/**
 * Search employees by name
 * CACHE FIX: Updated to call getAllEmployees_V2.
 */
function searchEmployees(searchTerm) {
  const allEmployees = getAllEmployees_V2(); // Use V2
  const term = searchTerm.toLowerCase();
  
  return allEmployees.filter(emp => 
    (emp.lastName || '').toLowerCase().includes(term) ||
    (emp.firstName || '').toLowerCase().includes(term) ||
    ((emp.lastName || '') + ' ' + (emp.firstName || '')).toLowerCase().includes(term)
  );
}

/**
 * Get active employees only
 * CACHE FIX: Updated to call getAllEmployees_V2.
 */
function getActiveEmployees() {
  const allEmployees = getAllEmployees_V2(); // Use V2
  return allEmployees.filter(emp => emp.status === 'Active');
}
